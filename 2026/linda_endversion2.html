<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>LINDA3 - Lernassistentin</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;700;800&family=Space+Grotesk:wght@600;700&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.8/purify.min.js"></script>
<style>
  :root {
    --ink: #111d2e;
    --ink-soft: #46556b;
    --brand: #0059b8;
    --brand-deep: #003f83;
    --brand-glow: #cae4ff;
    --mint: #00b894;
    --danger: #d7263d;
    --paper: #f4f8ff;
    --card: #ffffff;
    --line: #d6e0ef;
    --shadow: 0 14px 38px rgba(7, 21, 42, 0.12);
    --radius-xl: 22px;
    --radius-lg: 16px;
    --radius-sm: 11px;
    --header-h: 70px;
    --input-h: 92px;
    --kb: 0px;
  }

  * {
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
  }

  html,
  body {
    margin: 0;
    height: 100%;
    font-family: 'Manrope', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    color: var(--ink);
    background:
      radial-gradient(1200px 600px at 120% -10%, #d9ebff 0%, transparent 56%),
      radial-gradient(900px 480px at -20% 110%, #e4fff8 0%, transparent 58%),
      #e9f1fb;
    font-size: 16px;
    line-height: 1.55;
    text-size-adjust: 100%;
    -webkit-text-size-adjust: 100%;
  }

  body {
    display: flex;
    align-items: stretch;
    justify-content: center;
    padding: 0;
  }

  #app {
    width: 100%;
    height: 100dvh;
    background: linear-gradient(180deg, #fafdff 0%, #f2f7ff 100%);
    display: grid;
    grid-template-rows: var(--header-h) auto 1fr auto;
    overflow: hidden;
    position: relative;
  }

  @media (min-width: 980px) {
    body {
      padding: 20px;
    }

    #app {
      max-width: 1160px;
      border-radius: 26px;
      box-shadow: 0 24px 70px rgba(4, 20, 45, 0.25);
      height: min(96vh, 960px);
    }
  }

  header {
    background: rgba(255, 255, 255, 0.94);
    backdrop-filter: blur(12px);
    border-bottom: 1px solid var(--line);
    padding: 10px 12px;
    display: flex;
    align-items: center;
    gap: 10px;
    z-index: 8;
  }

  .logo-wrap {
    min-width: 0;
    flex: 1;
  }

  .logo {
    margin: 0;
    font-family: 'Space Grotesk', sans-serif;
    font-size: 1.3rem;
    letter-spacing: 0.02em;
    color: #0d3c77;
    white-space: nowrap;
  }

  .logo-sub {
    font-size: 0.75rem;
    color: var(--ink-soft);
    margin-top: 2px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .pill {
    border-radius: 999px;
    border: 1px solid #bdd7fa;
    color: #0d4b99;
    background: #ebf4ff;
    padding: 6px 10px;
    font-size: 0.72rem;
    font-weight: 700;
    white-space: nowrap;
  }

  .header-actions {
    display: flex;
    gap: 6px;
    overflow-x: auto;
  }

  .mobile-reader-toggle {
    display: none;
    align-items: center;
    gap: 6px;
    padding: 5px 7px;
    border: 1px solid #cddcf2;
    background: #f5f9ff;
    border-radius: 12px;
    flex-shrink: 0;
  }

  .mobile-reader-toggle .label {
    font-size: 0.68rem;
    font-weight: 800;
    color: #124a90;
    white-space: nowrap;
  }

  .mobile-reader-toggle label {
    display: inline-flex;
    align-items: center;
    gap: 3px;
    font-size: 0.68rem;
    color: #27486f;
    font-weight: 700;
  }

  .mobile-reader-toggle input {
    margin: 0;
  }

  .btn-icon {
    border: 1px solid var(--line);
    background: #fff;
    color: #0b3f80;
    border-radius: 12px;
    height: 44px;
    min-width: 44px;
    padding: 0 11px;
    font-weight: 800;
    font-size: 0.95rem;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }

  .btn-icon:hover,
  .btn-icon:focus-visible {
    background: #edf6ff;
    border-color: #9fc5f6;
    outline: none;
  }

  .btn-primary {
    background: linear-gradient(135deg, var(--brand) 0%, #1f77d8 100%);
    border: none;
    color: #fff;
  }

  .source-toolbar {
    border-bottom: 1px solid var(--line);
    background: rgba(255, 255, 255, 0.88);
    display: flex;
    gap: 8px;
    align-items: center;
    overflow-x: auto;
    padding: 8px 10px;
    min-height: 48px;
  }

  .smart-controls-bar {
    border-top: 1px solid #d9e4f5;
    border-bottom: 1px solid #d9e4f5;
    background: #f7fbff;
    padding: 8px 12px;
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 8px;
    font-size: 0.84rem;
    color: #23466f;
  }

  .smart-control {
    border: 1px solid #d6e4f8;
    border-radius: 11px;
    background: #fff;
    padding: 8px 9px;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 8px;
  }

  .smart-control .label {
    font-weight: 800;
    color: #0d4c96;
    white-space: nowrap;
  }

  .fastmode-choice {
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }

  .compare-canvas {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
  }

  .compare-col {
    border: 1px solid #d8e3f2;
    border-radius: 12px;
    background: #fbfdff;
    padding: 10px 10px 8px;
  }

  .compare-col-head {
    font-size: 0.76rem;
    font-weight: 800;
    color: #0d4c96;
    margin-bottom: 8px;
    text-transform: uppercase;
    letter-spacing: 0.03em;
  }

  .source-chip {
    border: 1px solid #d2dded;
    background: #fff;
    color: #28415e;
    border-radius: 999px;
    padding: 7px 10px;
    display: inline-flex;
    gap: 6px;
    align-items: center;
    font-size: 0.76rem;
    font-weight: 700;
    cursor: pointer;
    white-space: nowrap;
  }

  .source-chip.on {
    background: #e9f4ff;
    border-color: #8cb9ef;
    color: #044892;
  }

  .source-chip input {
    position: absolute;
    opacity: 0;
    width: 0;
    height: 0;
    pointer-events: none;
  }

  #chat-log {
    overflow-y: auto;
    padding: 14px;
    display: flex;
    flex-direction: column;
    gap: 12px;
    background:
      radial-gradient(520px 220px at 100% 0%, rgba(217, 234, 255, 0.7) 0%, transparent 80%),
      linear-gradient(180deg, #f9fcff 0%, #f3f8ff 100%);
    padding-bottom: calc(var(--input-h) + 18px + var(--kb));
  }

  .msg-row {
    width: 100%;
    display: flex;
    animation: fade-in 0.28s ease;
  }

  .msg-row.user {
    justify-content: flex-end;
  }

  .msg-row.assistant {
    justify-content: flex-start;
  }

  .msg-wrap {
    width: min(100%, 820px);
  }

  .bubble {
    border-radius: 17px;
    padding: 12px 14px;
    box-shadow: 0 2px 10px rgba(9, 26, 48, 0.08);
    word-break: break-word;
  }

  .bubble.user {
    background: linear-gradient(130deg, #0d58ae 0%, #2279d7 100%);
    color: #fff;
    border-radius: 18px 18px 6px 18px;
  }

  .bubble.assistant {
    background: #fff;
    border: 1px solid #d8e3f2;
    border-radius: 18px 18px 18px 6px;
  }

  .md h1,
  .md h2,
  .md h3 {
    font-family: 'Space Grotesk', sans-serif;
    margin: 0 0 8px;
    line-height: 1.25;
    color: #0d4b99;
  }

  .md p,
  .md ul,
  .md ol,
  .md pre,
  .md blockquote,
  .md table {
    margin: 0 0 10px;
  }

  .md ul,
  .md ol {
    padding-left: 20px;
  }

  .md pre {
    background: #eff5ff;
    border: 1px solid #d8e6fa;
    border-radius: 10px;
    padding: 10px;
    overflow: auto;
  }

  .md code {
    background: #eff5ff;
    border-radius: 6px;
    padding: 2px 6px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  }

  .md table {
    width: 100%;
    border-collapse: collapse;
    min-width: 340px;
  }

  .md th,
  .md td {
    border: 1px solid #dbe7f7;
    padding: 8px;
    text-align: left;
  }

  .md th {
    background: #edf5ff;
  }

  .table-wrap {
    overflow-x: auto;
    border-radius: 10px;
    border: 1px solid #dbe7f7;
  }

  .source-panel {
    margin-top: 8px;
    border: 1px solid #c7dcf8;
    border-radius: 11px;
    overflow: hidden;
    background: #f3f9ff;
  }

  .source-head {
    margin: 0;
    padding: 8px 10px;
    font-size: 0.78rem;
    color: #0e4e9d;
    border-bottom: 1px solid #d3e4fb;
  }

  .source-list {
    margin: 0;
    padding: 8px 10px 10px 24px;
    font-size: 0.9rem;
  }

  .source-list a {
    color: #0d58ae;
  }

  .source-missing {
    margin-top: 9px;
    color: #697a91;
    font-size: 0.84rem;
    font-style: italic;
  }

  .keyword-panel {
    margin-top: 8px;
    border: 1px solid #79c57d;
    border-radius: 11px;
    overflow: hidden;
    background: #f2fff3;
  }

  .keyword-head {
    margin: 0;
    padding: 8px 10px;
    font-size: 0.78rem;
    color: #1f6b2a;
    border-bottom: 1px solid #b9e5bd;
  }

  .keyword-list {
    margin: 0;
    padding: 8px 10px 10px 24px;
    font-size: 0.9rem;
  }

  .keyword-list a {
    color: #1f6b2a;
  }

  .case-disclaimer {
    margin-top: 10px;
    border: 1px solid #f4c47f;
    background: #fff7e9;
    color: #6a3f00;
    border-radius: 10px;
    padding: 9px 10px;
    font-size: 0.82rem;
    line-height: 1.4;
  }

  .msg-actions {
    margin-top: 6px;
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }

  .action-btn {
    border-radius: 999px;
    border: 1px solid #d2dceb;
    background: #fff;
    color: #2d4560;
    padding: 7px 11px;
    font-size: 0.77rem;
    font-weight: 700;
    cursor: pointer;
  }

  .action-btn:hover {
    background: #edf5ff;
  }

  .action-btn.strong {
    background: #e8f4ff;
    border-color: #9ec4f5;
    color: #0b4f9e;
  }

  .input-area {
    position: sticky;
    bottom: 0;
    border-top: 1px solid var(--line);
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(9px);
    min-height: var(--input-h);
    display: flex;
    gap: 10px;
    align-items: flex-end;
    padding: 10px 12px calc(10px + env(safe-area-inset-bottom));
    z-index: 7;
  }

  .input-wrap {
    flex: 1;
    position: relative;
  }

  #chat-input {
    width: 100%;
    min-height: 52px;
    max-height: 180px;
    resize: none;
    border: 2px solid #d9e2f1;
    background: #fcfdff;
    border-radius: 14px;
    padding: 12px 14px;
    font: inherit;
    outline: none;
  }

  #chat-input:focus {
    border-color: #3f88de;
    box-shadow: 0 0 0 4px #e8f3ff;
    background: #fff;
  }

  #send-btn {
    border: none;
    min-width: 50px;
    height: 50px;
    border-radius: 14px;
    background: linear-gradient(135deg, #0c63c5 0%, #0060bc 100%);
    color: #fff;
    font-size: 1rem;
    font-weight: 800;
    cursor: pointer;
  }

  #send-btn.stop {
    background: linear-gradient(135deg, #da2f45 0%, #b92434 100%);
  }

  #snippet-popup {
    position: absolute;
    left: 0;
    right: 0;
    bottom: calc(100% + 8px);
    border: 1px solid #d5dfef;
    background: #fff;
    border-radius: 12px;
    overflow: auto;
    max-height: 230px;
    box-shadow: var(--shadow);
    display: none;
    z-index: 15;
  }

  #snippet-popup.active {
    display: block;
  }

  .snippet-item {
    padding: 10px 12px;
    border-bottom: 1px solid #edf1f7;
    cursor: pointer;
  }

  .snippet-item:hover {
    background: #f2f8ff;
  }

  .snippet-item:last-child {
    border-bottom: none;
  }

  .loading {
    display: inline-flex;
    gap: 6px;
  }

  .loading span {
    width: 9px;
    height: 9px;
    border-radius: 999px;
    background: #0f61c1;
    animation: pulse 0.95s ease-in-out infinite;
  }

  .loading span:nth-child(2) { animation-delay: 0.12s; }
  .loading span:nth-child(3) { animation-delay: 0.24s; }

  .modal-overlay {
    position: fixed;
    inset: 0;
    background: rgba(8, 21, 41, 0.56);
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 14px;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease;
    z-index: 50;
  }

  .modal-overlay.open {
    opacity: 1;
    pointer-events: auto;
  }

  .modal {
    background: #fff;
    width: min(100%, 640px);
    border-radius: var(--radius-lg);
    max-height: 90vh;
    overflow: auto;
    padding: 18px;
    box-shadow: 0 22px 58px rgba(2, 15, 32, 0.38);
  }

  .modal h3 {
    margin: 0 0 12px;
    font-family: 'Space Grotesk', sans-serif;
    color: #0d4a94;
  }

  .grid {
    display: grid;
    gap: 10px;
  }

  .grid.cols-2 {
    grid-template-columns: 1fr 1fr;
  }

  .field label {
    font-size: 0.84rem;
    color: #3e536e;
    display: block;
    margin-bottom: 4px;
    font-weight: 700;
  }

  .field input,
  .field select,
  .field textarea {
    width: 100%;
    border: 2px solid #d9e3f2;
    border-radius: 10px;
    padding: 10px 11px;
    font: inherit;
    background: #fdfeff;
  }

  .field textarea {
    min-height: 72px;
    resize: vertical;
  }

  .field input:focus,
  .field select:focus,
  .field textarea:focus {
    outline: none;
    border-color: #2f80d8;
    box-shadow: 0 0 0 3px #eaf4ff;
  }

  .section {
    border: 1px solid #dce5f3;
    background: #f8fbff;
    border-radius: 12px;
    padding: 12px;
  }

  .section h4 {
    margin: 0 0 8px;
    font-size: 0.92rem;
    color: #124a8f;
  }

  .mini {
    margin: 0;
    font-size: 0.8rem;
    color: #5c6f86;
  }

  .toggle-list {
    display: grid;
    gap: 8px;
  }

  .toggle-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 12px;
    border: 1px solid #d7e2f2;
    border-radius: 10px;
    background: #fff;
    padding: 9px 10px;
  }

  .toggle-row label {
    font-size: 0.9rem;
    font-weight: 700;
    color: #22415f;
  }

  .toggle-row input {
    width: 18px;
    height: 18px;
    margin: 0;
    accent-color: #0f65c8;
  }

  .btn-row {
    margin-top: 14px;
    display: flex;
    gap: 8px;
  }

  .btn {
    flex: 1;
    border: none;
    border-radius: 11px;
    padding: 10px 12px;
    font: inherit;
    font-weight: 800;
    cursor: pointer;
  }

  .btn.save {
    background: linear-gradient(130deg, #0c63c5 0%, #1676d2 100%);
    color: #fff;
  }

  .btn.cancel {
    background: #e8edf6;
    color: #1f3047;
  }

  .btn.warn {
    background: #ffeff1;
    color: #8c1f2c;
    border: 1px solid #ffd3d8;
  }

  .list {
    border: 1px solid #d7e2f2;
    border-radius: 11px;
    overflow: hidden;
    background: #fff;
  }

  .list-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
    padding: 10px 12px;
    border-bottom: 1px solid #e8eef7;
    cursor: pointer;
  }

  .list-item:last-child {
    border-bottom: none;
  }

  .list-item.active {
    background: #eaf4ff;
    color: #08488f;
    font-weight: 700;
  }

  .consent {
    border-top: 5px solid #0c61c2;
  }

  .check-row {
    display: flex;
    align-items: flex-start;
    gap: 10px;
    margin: 10px 0;
  }

  .check-row input {
    margin-top: 3px;
    width: 18px;
    height: 18px;
    accent-color: #0f66c8;
  }

  .cards-layout {
    min-height: 100dvh;
    background:
      radial-gradient(600px 300px at 10% 0%, #d8f6ff 0%, transparent 64%),
      radial-gradient(800px 460px at 100% 100%, #dce7ff 0%, transparent 58%),
      #edf4ff;
    display: flex;
    flex-direction: column;
    color: #0f2138;
  }

  .cards-top {
    display: flex;
    gap: 8px;
    align-items: center;
    justify-content: space-between;
    padding: 14px;
    border-bottom: 1px solid #cfe0f8;
    background: rgba(255,255,255,0.75);
    backdrop-filter: blur(8px);
  }

  .cards-title {
    margin: 0;
    font-family: 'Space Grotesk', sans-serif;
    font-size: 1.14rem;
    color: #0c4f98;
  }

  .cards-sub {
    margin: 2px 0 0;
    font-size: 0.8rem;
    color: #4f637f;
  }

  .cards-body {
    width: min(960px, 100%);
    margin: 0 auto;
    padding: 16px 14px 28px;
    display: grid;
    gap: 14px;
    grid-template-columns: repeat(auto-fill, minmax(230px, 1fr));
  }

  .flash {
    perspective: 1000px;
    min-height: 190px;
  }

  .flash-toggle {
    width: 100%;
    min-height: 190px;
    border: none;
    background: none;
    padding: 0;
    text-align: left;
    cursor: pointer;
    display: block;
  }

  .flash-inner {
    position: relative;
    min-height: 190px;
    transform-style: preserve-3d;
    transition: transform 0.5s ease;
  }

  .flash.flipped .flash-inner {
    transform: rotateY(180deg);
  }

  .flash-face {
    position: absolute;
    inset: 0;
    backface-visibility: hidden;
    border-radius: 14px;
    box-shadow: 0 10px 28px rgba(11, 26, 43, 0.13);
    border: 1px solid #d4e3f8;
    padding: 12px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    overflow: auto;
  }

  .flash-face.front {
    background: linear-gradient(135deg, #ffffff 0%, #f4f9ff 100%);
  }

  .flash-face.back {
    background: linear-gradient(135deg, #e9f5ff 0%, #ddedff 100%);
    transform: rotateY(180deg);
  }

  .flash-kicker {
    margin: 0;
    font-size: 0.68rem;
    color: #4a6587;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    font-weight: 800;
  }

  .flash h4 {
    margin: 0;
    font-size: 1.03rem;
    line-height: 1.35;
    color: #103766;
  }

  .flash p {
    margin: 0;
    font-size: 0.94rem;
    color: #18395f;
  }

  .state-msg {
    padding: 16px;
    border: 1px dashed #b7cae8;
    border-radius: 12px;
    background: #f8fbff;
    color: #415b79;
  }

  .practice-card {
    border: 1px solid #d2e2f6;
    border-radius: 14px;
    background: #fff;
    padding: 14px;
    box-shadow: 0 8px 20px rgba(12, 41, 74, 0.06);
  }

  .practice-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px;
  }

  .practice-header h3 {
    margin: 0;
    font-size: 1.02rem;
    color: #123f72;
  }

  .practice-points {
    border: 1px solid #c5d9f5;
    color: #1b4f8a;
    border-radius: 999px;
    padding: 4px 8px;
    font-size: 0.78rem;
    font-weight: 700;
    background: #f3f8ff;
  }

  .practice-question {
    margin: 0 0 10px;
    color: #1d3652;
    line-height: 1.5;
  }

  .practice-options {
    display: grid;
    gap: 8px;
    margin-bottom: 10px;
  }

  .practice-option {
    display: flex;
    align-items: flex-start;
    gap: 8px;
    border: 1px solid #d7e4f8;
    border-radius: 10px;
    padding: 9px 10px;
    background: #fbfdff;
    font-size: 0.94rem;
    color: #233c57;
  }

  .practice-open-answer {
    width: 100%;
    min-height: 94px;
    border: 1px solid #c8d9f4;
    border-radius: 10px;
    padding: 10px;
    font: inherit;
    resize: vertical;
    background: #fdfefe;
  }

  .practice-actions {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }

  .practice-solution {
    margin-top: 10px;
    border: 1px solid #c8ddf8;
    border-radius: 10px;
    background: #f4f9ff;
    padding: 10px;
    font-size: 0.92rem;
    color: #1e436b;
  }

  .selection-template-grid {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 8px;
  }

  .selection-template {
    border: 1px solid #cfe0f7;
    border-radius: 12px;
    padding: 10px;
    cursor: pointer;
    background: #f8fbff;
  }

  .selection-template.active {
    border-color: #2372ce;
    background: #eaf3ff;
  }

  .selection-template strong {
    display: block;
    margin-bottom: 4px;
    color: #0f4f9a;
  }

  .selection-template small {
    color: #506986;
    display: block;
  }

  .mode-card {
    border: 1px solid #cfe0f7;
    background: #f6fbff;
    border-radius: 14px;
    padding: 12px;
  }

  .mode-card h4 {
    margin: 0 0 8px;
    color: #0e4f9f;
    font-size: 1rem;
  }

  .mode-card p {
    margin: 0 0 10px;
    color: #3a5575;
    font-size: 0.92rem;
  }

  .mode-grid {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 8px;
  }

  .mode-btn {
    border: 1px solid #b8d2f1;
    background: #fff;
    color: #124c95;
    border-radius: 10px;
    padding: 9px 8px;
    font-weight: 800;
    font-size: 0.84rem;
    cursor: pointer;
  }

  .mode-btn:hover {
    background: #ecf5ff;
  }

  @keyframes fade-in {
    from { opacity: 0; transform: translateY(6px); }
    to { opacity: 1; transform: translateY(0); }
  }

  @keyframes pulse {
    0%, 100% { opacity: 0.4; transform: scale(0.8); }
    50% { opacity: 1; transform: scale(1); }
  }

  @media (max-width: 920px) {
    :root {
      --header-h: 64px;
      --input-h: 98px;
    }

    html, body {
      font-size: 18px;
    }

    .bubble {
      font-size: 1.06rem;
      line-height: 1.62;
      padding: 14px 16px;
    }

    #chat-input {
      font-size: 18px;
      min-height: 64px;
      line-height: 1.5;
    }

    .grid.cols-2 {
      grid-template-columns: 1fr;
    }

    .selection-template-grid {
      grid-template-columns: 1fr;
    }

    .header-actions .btn-icon span {
      display: none;
    }

    .mobile-reader-toggle {
      display: inline-flex;
    }

    .logo-sub {
      max-width: 36vw;
    }

    .source-toolbar {
      padding: 7px 8px;
      gap: 6px;
    }

    .source-chip {
      padding: 6px 9px;
      font-size: 0.73rem;
    }

    .action-btn {
      flex: 1;
      text-align: center;
      min-width: 0;
    }

    header,
    .input-area,
    .cards-top {
      backdrop-filter: none;
    }

    .mode-grid {
      grid-template-columns: 1fr;
    }

    .smart-controls-bar {
      grid-template-columns: 1fr;
      font-size: 0.92rem;
      padding: 10px 12px;
      gap: 10px;
    }

    .smart-control {
      padding: 10px 10px;
      gap: 10px;
    }

    .compare-canvas {
      grid-template-columns: 1fr;
    }
  }

  body.mobile-fallback .logo-sub {
    display: none;
  }

  body.mobile-fallback .source-chip {
    font-size: 0.84rem;
    padding: 8px 12px;
  }

  body.mobile-reader {
    background: #f5f8fc;
  }

  body.mobile-reader #app {
    background: #f9fbfe;
  }

  body.mobile-reader #domain-badge,
  body.mobile-reader .header-actions,
  body.mobile-reader .source-toolbar,
  body.mobile-reader .smart-controls-bar,
  body.mobile-reader .msg-actions,
  body.mobile-reader .source-panel {
    display: none !important;
  }

  body.mobile-reader .logo {
    font-size: 1.2rem;
  }

  body.mobile-reader .logo-sub {
    display: none;
  }

  body.mobile-reader #chat-log {
    padding-top: 12px;
    padding-bottom: calc(var(--input-h) + 28px);
  }

  body.mobile-reader .bubble {
    font-size: 1.1rem;
    line-height: 1.72;
    padding: 16px 17px;
  }

  body.mobile-reader #chat-input {
    font-size: 19px;
    line-height: 1.58;
    min-height: 72px;
  }

  #selection-menu {
    position: fixed;
    z-index: 1300;
    background: #ffffff;
    border: 1px solid #cddcf2;
    border-radius: 12px;
    box-shadow: 0 14px 30px rgba(8, 26, 53, 0.18);
    padding: 8px;
    min-width: 230px;
    display: none;
  }

  #selection-menu.active {
    display: block;
  }

  #selection-menu .title {
    font-size: 0.74rem;
    color: #4f6280;
    margin-bottom: 6px;
  }

  #selection-menu .sel-btn {
    width: 100%;
    border: 1px solid #b7cff0;
    background: #f1f8ff;
    color: #0a4d99;
    border-radius: 10px;
    padding: 9px 10px;
    font-weight: 800;
    font-size: 0.83rem;
    cursor: pointer;
    text-align: left;
  }

  #selection-menu .sel-btn[disabled] {
    opacity: 0.45;
    cursor: not-allowed;
  }

  #selection-menu .selection-note {
    font-size: 0.72rem;
    color: #5c6f8e;
    margin-top: 7px;
    line-height: 1.35;
  }

  .selection-modal {
    position: fixed;
    inset: 0;
    z-index: 1350;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(7, 20, 40, 0.4);
    padding: 14px;
  }

  .selection-modal.open {
    display: flex;
  }

  .selection-modal-card {
    width: min(560px, 100%);
    background: #ffffff;
    border: 1px solid #cfdbef;
    border-radius: 14px;
    box-shadow: 0 22px 46px rgba(8, 24, 52, 0.25);
    padding: 14px;
  }

  .selection-modal-card h4 {
    margin: 0 0 8px 0;
    font-size: 1rem;
    color: #123f74;
  }

  .selection-preview {
    margin: 0 0 10px;
    padding: 9px 10px;
    border: 1px solid #d5e2f6;
    border-radius: 10px;
    font-size: 0.84rem;
    color: #2f4d72;
    background: #f6faff;
    max-height: 130px;
    overflow: auto;
    white-space: pre-wrap;
  }

  .selection-field {
    display: grid;
    gap: 5px;
    margin-bottom: 11px;
  }

  .selection-field label {
    font-size: 0.75rem;
    text-transform: uppercase;
    font-weight: 800;
    letter-spacing: 0.03em;
    color: #2a4b74;
  }

  .selection-field select,
  .selection-field input,
  .selection-result-text {
    width: 100%;
    border: 1px solid #c6d8f1;
    border-radius: 10px;
    padding: 9px 10px;
    font: inherit;
  }

  .selection-result-text {
    min-height: 200px;
    resize: vertical;
    font-size: 0.91rem;
    line-height: 1.5;
  }

  .selection-modal-actions {
    display: flex;
    justify-content: flex-end;
    gap: 8px;
    flex-wrap: wrap;
    margin-top: 10px;
  }

  @media (prefers-reduced-motion: reduce) {
    *, *::before, *::after {
      animation: none !important;
      transition: none !important;
      scroll-behavior: auto !important;
    }
  }
</style>
</head>
<body>
<div id="app" aria-live="polite">
  <header>
    <div class="logo-wrap">
      <h1 class="logo">LINDA3</h1>
      <div class="logo-sub" id="domain-summary">Lernassistenz für geschulte Anwender</div>
    </div>
    <div class="mobile-reader-toggle" id="mobile-reader-toggle" aria-label="Mobiler Lesemodus">
      <span class="label">Mobil</span>
      <label for="mobile-reader-off">
        <input id="mobile-reader-off" type="radio" name="mobile-reader-mode" value="off">
        <span>Normal</span>
      </label>
      <label for="mobile-reader-on">
        <input id="mobile-reader-on" type="radio" name="mobile-reader-mode" value="on">
        <span>Lesen</span>
      </label>
    </div>
    <div id="domain-badge" class="pill">Standard</div>
    <div class="header-actions">
      <button class="btn-icon btn-primary" title="Neuer Chat" onclick="app.logic.newChat()">Neu</button>
      <button class="btn-icon" title="Verlauf" onclick="app.ui.openModal('modal-sessions')">Verlauf</button>
      <button class="btn-icon" title="Einstellungen" onclick="app.ui.openModal('modal-settings')">Einstellungen</button>
    </div>
  </header>

  <div class="source-toolbar" id="source-toolbar"></div>

  <div id="chat-log"></div>

  <div class="smart-controls-bar" aria-label="Smart Schalter">
    <div class="smart-control">
      <span class="label">Schnellmodus</span>
      <label class="fastmode-choice">
        <input id="fastmode-main-on" type="radio" name="fastmode-main" value="on">
        <span>Ein</span>
      </label>
      <label class="fastmode-choice">
        <input id="fastmode-main-off" type="radio" name="fastmode-main" value="off">
        <span>Aus</span>
      </label>
    </div>
    <div class="smart-control">
      <span class="label">Antwortmodus</span>
      <label class="fastmode-choice">
        <input id="compare-main-off" type="radio" name="compare-main" value="off">
        <span>Standard</span>
      </label>
      <label class="fastmode-choice">
        <input id="compare-main-on" type="radio" name="compare-main" value="on">
        <span>Canvas</span>
      </label>
    </div>
    <div class="smart-control">
      <span class="label">Lernverzeichnis (BETA)</span>
      <label class="fastmode-choice">
        <input id="directory-main-on" type="radio" name="directory-main" value="on">
        <span>Ein</span>
      </label>
      <label class="fastmode-choice">
        <input id="directory-main-off" type="radio" name="directory-main" value="off">
        <span>Aus</span>
      </label>
    </div>
  </div>

  <div class="input-area">
    <div class="input-wrap">
      <div id="snippet-popup"></div>
      <textarea id="chat-input" rows="1" placeholder="Frage eingeben...  (Shift+Enter für Zeilenumbruch)"></textarea>
    </div>
    <button id="send-btn" type="button" aria-label="Senden">➤</button>
  </div>
</div>

<div id="modal-disclaimer" class="modal-overlay open">
  <div class="modal consent">
    <h3>Datenschutzhinweise</h3>
    <p>Bitte keine vertraulichen personenbezogenen Daten eingeben. Inhalte können an aktivierte Dienste übermittelt werden.</p>
    <ul>
      <li>KI-Dienste (z.B. OpenAI / Anthropic)</li>
      <li>Automations-Dienste (z.B. Make)</li>
      <li>Optional ILIAS-Inhalte (manuell zuschaltbar)</li>
    </ul>
    <div class="check-row">
      <input type="checkbox" id="consent-data">
      <label for="consent-data">Ich gebe keine sensiblen personenbezogenen Daten ein.</label>
    </div>
    <div class="check-row">
      <input type="checkbox" id="consent-forward">
      <label for="consent-forward">Ich stimme der Weiterleitung an aktivierte Quellen/Schnittstellen zu.</label>
    </div>
    <div class="btn-row">
      <button class="btn save" id="btn-start-disclaimer" disabled onclick="app.logic.startApp()">Akzeptieren und starten</button>
    </div>
  </div>
</div>

<div id="modal-settings" class="modal-overlay">
  <div class="modal">
    <h3>Einstellungen</h3>
    <div class="grid cols-2">
      <div class="field">
        <label for="inp-name">Name (optional)</label>
        <input id="inp-name" type="text" placeholder="z.B. Max">
      </div>
      <div class="field">
        <label for="inp-domain">Fachmodus</label>
        <select id="inp-domain">
          <option value="">Standard</option>
          <option value="AEVO">Ausbilder (AEVO)</option>
          <option value="VWL">VWL / Betriebswirtschaft</option>
          <option value="PERSONAL">Personalwesen</option>
        </select>
      </div>
    </div>

    <div class="section" style="margin-top:10px;">
      <h4>Wissensquellen</h4>
      <p class="mini">Du kannst die genutzten Wissensbereiche hier ein- und ausschalten.</p>
      <div class="toggle-list" id="source-toggle-list"></div>
    </div>

    <div class="section" style="margin-top:10px;">
      <h4>ILIAS (BETA)</h4>
      <p class="mini">ILIAS ist aktuell Beta und wird nur per Schalter bei den Wissensquellen aktiviert. Keine Token-Eingabe im Frontend.</p>
    </div>

    <div class="section" style="margin-top:10px;">
      <h4>API Health</h4>
      <p class="mini">Prüft, ob die benötigten Environment-Variablen für diese Site gesetzt sind.</p>
      <div class="btn-row" style="margin-top:8px;">
        <button class="btn save" type="button" onclick="app.logic.checkApiHealth()">Health prüfen</button>
      </div>
      <pre id="api-health-status" class="mini" style="margin-top:8px; background:#f4f8ff; border:1px solid #d7e4f8; border-radius:10px; padding:10px; white-space:pre-wrap;">Noch nicht geprüft.</pre>
    </div>

    <div class="section" style="margin-top:10px;">
      <h4>Prompting-Vorschläge</h4>
      <p class="mini">Optional zuschaltbar. Vorschläge werden lokal erzeugt und nicht als feste Prompt-Vorgabe an den Bot gesendet.</p>
      <div class="toggle-row" style="margin-top:8px;">
        <label for="inp-prompting-enabled">Vorschläge aktivieren</label>
        <input id="inp-prompting-enabled" type="checkbox">
      </div>
      <div class="field" style="margin-top:8px;">
        <label for="inp-prompting-json">Vorschlags-JSON</label>
        <textarea id="inp-prompting-json" rows="8" style="width:100%; border:2px solid #d9e3f2; border-radius:10px; padding:10px 11px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 0.82rem;"></textarea>
      </div>
    </div>

    <div class="section" style="margin-top:10px;">
      <h4>Lernkarten Webhook (Auswahl)</h4>
      <p class="mini">Definiert, wie markierte Antwortbereiche an den Webhook für Lernkarten übergeben werden.</p>
      <div class="field" style="margin-top:8px;">
        <label for="inp-cards-webhook-json">Webhook-JSON</label>
        <textarea id="inp-cards-webhook-json" rows="7" style="width:100%; border:2px solid #d9e3f2; border-radius:10px; padding:10px 11px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 0.82rem;"></textarea>
      </div>
    </div>

    <div class="section" style="margin-top:10px;">
      <h4>Snippets</h4>
      <div style="display:flex; gap:8px;">
        <input id="inp-snippet" type="text" placeholder="Snippet hinzufügen" style="flex:1; border:2px solid #d9e3f2; border-radius:10px; padding:10px 11px;">
        <button class="btn save" style="flex:0 0 60px;" onclick="app.logic.addSnippet()">+</button>
      </div>
      <div id="snippet-list-container" style="display:flex; flex-wrap:wrap; gap:6px; margin-top:8px;"></div>
      <p class="mini" style="margin-top:8px;">Im Chat mit <code>/</code> starten, um Snippets vorzuschlagen.</p>
    </div>

    <div class="btn-row">
      <button class="btn cancel" onclick="app.ui.closeModals()">Abbrechen</button>
      <button class="btn save" onclick="app.logic.saveSettings()">Speichern</button>
    </div>
  </div>
</div>

<div id="modal-sessions" class="modal-overlay">
  <div class="modal">
    <h3>Verlauf</h3>
    <div id="session-list" class="list"></div>
    <p class="mini" style="margin-top:8px;">Es werden bis zu 12 Sitzungen angezeigt.</p>
    <div class="btn-row">
      <button class="btn warn" onclick="app.logic.clearAll()">Alle löschen</button>
      <button class="btn cancel" onclick="app.ui.closeModals()">Schließen</button>
    </div>
  </div>
</div>

<div id="modal-feedback" class="modal-overlay">
  <div class="modal">
    <h3>Feedback</h3>
    <p>Feedback per E-Mail senden?</p>
    <div class="btn-row">
      <button class="btn cancel" onclick="app.ui.closeModals()">Nein</button>
      <button class="btn save" onclick="app.logic.openFeedback()">Ja</button>
    </div>
  </div>
</div>

<div id="selection-menu" role="menu" aria-label="Auswahlmenü">
  <div class="title">Markierter Bereich erkannt</div>
  <button id="selection-cards-btn" class="sel-btn" type="button">Lernkarten erstellen</button>
  <button id="selection-practice-btn" class="sel-btn" type="button">Übungsaufgaben erstellen</button>
  <button id="selection-translate-btn" class="sel-btn" type="button">Übersetzen</button>
  <button id="selection-rewrite-btn" class="sel-btn" type="button">Komprimiere Inhalt</button>
  <div class="selection-note" id="selection-note">Zeichen: 0</div>
</div>

<div id="selection-action-modal" class="selection-modal" aria-hidden="true">
  <div class="selection-modal-card">
    <h4 id="selection-action-title">Aktion</h4>
    <p class="selection-preview" id="selection-action-preview"></p>
    <div id="selection-action-fields"></div>
    <div class="selection-modal-actions">
      <button class="btn cancel" id="selection-action-cancel" type="button">Abbrechen</button>
      <button class="btn save" id="selection-action-confirm" type="button">Ausführen</button>
    </div>
  </div>
</div>

<div id="selection-result-modal" class="selection-modal" aria-hidden="true">
  <div class="selection-modal-card">
    <h4 id="selection-result-title">Ergebnis</h4>
    <textarea id="selection-result-text" class="selection-result-text" spellcheck="false"></textarea>
    <div class="selection-modal-actions">
      <button class="btn save" id="selection-result-copy" type="button">Kopieren</button>
      <button class="btn save" id="selection-result-speak" type="button">Vorlesen</button>
      <button class="btn cancel" id="selection-result-close" type="button">Schließen</button>
    </div>
  </div>
</div>

<script>
(() => {
  'use strict';

  const API_ENDPOINT = '/api/linda3?action=bot';
  const DEEPSEEK_API_ENDPOINT = '/api/linda3?action=deepseek';
  const HEALTH_API_ENDPOINT = '/api/linda3?action=health';
  const BBIG_PDF_PATH = 'https://vercel-kappa-seven-33.vercel.app/2026/document/BBIG_V20022026.pdf';
  const DIRECTORY_LINKS_PATH = './directory_links.json';
  const DIRECTORY_KEYWORD_MATCHING_ENABLED = false;
  const STORAGE_KEY = 'linda3_state';
  const REQUEST_MEMORY_KEY = 'linda3_request_memory';
  const CARDS_KEY = 'linda3_cards';
  const PRACTICE_KEY = 'linda3_practice';
  const CARDS_STATS_KEY = 'linda3_cards_stats';
  const FLASHCARDS_API_ENDPOINT = '/api/linda3?action=flashcards';
  const TRANSLATE_API_ENDPOINT = '/api/linda3?action=translate';
  const REWRITE_API_ENDPOINT = '/api/linda3?action=rewrite';
  const TTS_API_ENDPOINT = '/api/linda3?action=tts';
  const LEARNING_TEMPLATES_PATH = './docs/learning_templates.json';
  const APP_VERSION = 3;
  const REQUEST_MEMORY_VERSION = 1;

  const SOURCE_DEFS = [
    { key: 'llm', label: 'Basiswissen', default: true },
    { key: 'web', label: 'Aktuelle Informationen', default: true },
    { key: 'script', label: 'Ihre Unterlagen', default: true },
    { key: 'ilias', label: 'Kursraum (ILIAS) BETA', default: false },
    { key: 'directory', label: 'Lernverzeichnis BETA', default: false }
  ];

  const DEFAULT_PROMPTING_JSON = {
    inlineExpansions: [
      { pattern: "der\\s+auszu$", replacement: "der Auszubildende " },
      { pattern: "die\\s+auszu$", replacement: "die Auszubildende " }
    ],
    quickSuggestions: [
      "Formuliere die Antwort bitte in einfacher Sprache.",
      "Nenne bitte ein kurzes Praxisbeispiel zur Situation."
    ],
    modeCards: [
      { key: "AEVO", label: "AEVO", hint: "Ausbilder-Themen" },
      { key: "VWL", label: "VWL/BWL", hint: "Wirtschaftsbezug" },
      { key: "PERSONAL", label: "Personal", hint: "Personalwesen" }
    ]
  };

  const DEFAULT_CARDS_WEBHOOK_JSON = {
    enabled: true,
    endpointPath: "/api/linda3?action=bot",
    minSelectionChars: 24,
    targetCount: 8,
    requireConfirmation: true,
    adaptive: true
  };

  const DEFAULT_LEARNING_TEMPLATES = {
    version: '1.0',
    flashcards: {
      instruction_template:
        'Erstelle aus dem folgenden Inhalt genau {{count}} hochwertige Lernkarten. ' +
        'Antwort ausschliesslich als JSON ohne Markdown im Format {"deckTitle":"...","cards":[{"question":"...","answer":"..."}]}. ' +
        'Regeln: Nur fachlich relevante Inhalte, keine Meta-Hinweise, kurze und pruefungsorientierte Antworten. ' +
        'Fachmodus: {{domain}}. Inhalt: {{content}}'
    },
    practice: {
      title_prefix: 'Uebungsaufgaben',
      instruction_template:
        'Analysiere den Inhalt gruendlich und erstelle durchdachte Uebungsaufgaben im Modus {{template_label}} mit Niveau {{difficulty}}. ' +
        'Liefere JSON ohne Markdown im Format {"title":"...","questions":[{"type":"mc","question":"...","options":["..."],"correctIndices":[0],"hint":"...","solution":"...","points":2}]}. ' +
        'Fuer MC mindestens 4 Optionen. Kontext: {{content}}',
      templates: [
        { id: 'quick_quiz', label: 'Schnelles Quiz', description: 'Kurze Wiederholung von Fakten und Definitionen', duration: '5 Minuten', default_count: 4, supports_open: false },
        { id: 'multiple_choice', label: 'Multiple Choice', description: 'Prueft Verstaendnis auf mehreren Ebenen', duration: '10 Minuten', default_count: 6, supports_open: false },
        { id: 'progressive', label: 'Progressive Uebung', description: 'Steigendes Niveau inkl. Transferaufgaben', duration: '15 Minuten', default_count: 6, supports_open: true },
        { id: 'deep_dive', label: 'Deep Dive', description: 'Anwendung, Begruendung und kritisches Denken', duration: '25 Minuten', default_count: 8, supports_open: true }
      ],
      difficulties: ['leicht', 'mittel', 'anspruchsvoll']
    }
  };
  let learningTemplatesCache = structuredClone(DEFAULT_LEARNING_TEMPLATES);
  let activeTtsAudio = null;
  let activeTtsAudioUrl = '';

  const DEFAULT_REQUEST_MEMORY = {
    version: REQUEST_MEMORY_VERSION,
    maxEntries: 120,
    updatedAt: null,
    entries: []
  };

  const DEFAULT_DIRECTORY_LINKS = {
    version: '1.0',
    description: 'Einfache Linkliste fuer Dozenten (Titel, URL, Keywords).',
    entries: []
  };

  const MAKEFLOW_ONLY_SOURCES = {
    llm: false,
    web: false,
    script: true,
    ilias: false,
    directory: false
  };

  const DEFAULT_STATE = {
    version: APP_VERSION,
    consentGiven: false,
    isSending: false,
    welcomeShown: false,
    lastQuestion: '',
    requestMemory: structuredClone(DEFAULT_REQUEST_MEMORY),
    activeId: null,
    requestController: null,
    isCardsRequestRunning: false,
    selectionDraft: null,
    settings: {
        name: '',
        domain: '',
        snippets: [],
      sources: SOURCE_DEFS.reduce((acc, s) => {
        acc[s.key] = s.default;
        return acc;
      }, {}),
      ilias: {
        enabled: false,
        courseId: ''
      },
      fastMode: {
        enabled: false,
        consentAccepted: false
      },
      compareMode: {
        enabled: false
      },
      mobileReader: {
        enabled: false
      },
      prompting: {
        enabled: false,
        config: DEFAULT_PROMPTING_JSON
      },
      cardsWebhook: DEFAULT_CARDS_WEBHOOK_JSON
    },
    cards: {
      lastDeckTitle: ''
    },
    apiHealth: {
      ok: null,
      checks: {},
      ts: ''
    },
    keywordLinks: structuredClone(DEFAULT_DIRECTORY_LINKS),
    telemetry: {
      firstSelectionHintShown: false
    }
  };

  const hashCardId = (q, a) => {
    try {
      return btoa(unescape(encodeURIComponent(`${q}|${a}`))).slice(0, 24);
    } catch (_) {
      return String(`${q}|${a}`).slice(0, 24);
    }
  };

  const normalizeWebhookCards = (items) => {
    if (!Array.isArray(items)) return [];
    return items
      .map((it) => {
        if (!it || typeof it !== 'object') return null;
        const q = String(it.question || it.front || '').trim();
        const a = String(it.answer || it.back || '').trim();
        if (!q || !a) return null;
        return { question: q, answer: a, id: hashCardId(q, a), adaptive: { ease: 2, reps: 0, dueAt: 0 } };
      })
      .filter(Boolean);
  };

  const parseCardsWebhookResponse = (rawText) => {
    const clean = String(rawText || '')
      .replace(/```json/gi, '```')
      .replace(/```/g, '')
      .trim();
    const parsed = parseJSON(clean, null) || parseJSON((clean.match(/\{[\s\S]*\}/) || [])[0], null);
    if (!parsed) return null;
    if (Array.isArray(parsed)) return { deckTitle: 'Lernkarten', cards: normalizeWebhookCards(parsed) };
    if (typeof parsed !== 'object') return null;
    return {
      deckTitle: String(parsed.deckTitle || parsed.title || 'Lernkarten').trim(),
      cards: normalizeWebhookCards(parsed.cards || parsed.items || [])
    }
  };

  const parseJSON = (raw, fallback) => {
    try {
      return JSON.parse(raw);
    } catch (_) {
      return fallback;
    }
  };

  const app = {
    state: structuredClone(DEFAULT_STATE),

    utils: {
      uid: () => 's_' + Date.now().toString(36) + Math.random().toString(36).slice(2, 7),
      now: () => Date.now(),
      safeText: (v) => String(v || '').replace(/</g, '&lt;').replace(/>/g, '&gt;'),
      truncate: (text, max = 1900) => {
        if (!text || text.length <= max) return text;
        return text.slice(0, Math.max(0, max - 3)) + '...';
      },
      normalizeQuestion: (text) => {
        return String(text || '')
          .toLowerCase()
          .replace(/[^a-z0-9äöüß\s]/gi, ' ')
          .replace(/\s+/g, ' ')
          .trim();
      },
      questionTokens: (text) => {
        return app.utils.normalizeQuestion(text)
          .split(' ')
          .filter((t) => t.length >= 3)
          .slice(0, 20);
      },
      normalizeForKeyword: (text) => {
        return String(text || '')
          .toLowerCase()
          .replace(/[ä]/g, 'ae')
          .replace(/[ö]/g, 'oe')
          .replace(/[ü]/g, 'ue')
          .replace(/[ß]/g, 'ss')
          .replace(/[^a-z0-9\s]/g, ' ')
          .replace(/\s+/g, ' ')
          .trim();
      },
      save: () => {
        const requestMemory = app.state.requestMemory || structuredClone(DEFAULT_REQUEST_MEMORY);
        const clone = {
          ...app.state,
          requestController: null,
          isSending: false,
          requestMemory: undefined
        };
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(clone));
          localStorage.setItem(REQUEST_MEMORY_KEY, JSON.stringify(requestMemory));
        } catch (e) {
          console.error('save failed', e);
        }
      },
      load: () => {
        const raw = localStorage.getItem(STORAGE_KEY);
        const memoryRaw = localStorage.getItem(REQUEST_MEMORY_KEY);
        const memoryParsed = memoryRaw ? parseJSON(memoryRaw, null) : null;
        if (!raw) {
          if (memoryParsed && typeof memoryParsed === 'object') {
            app.state.requestMemory = {
              ...structuredClone(DEFAULT_REQUEST_MEMORY),
              ...memoryParsed
            };
            app.state.requestMemory.maxEntries = Math.max(30, Number(app.state.requestMemory.maxEntries) || 120);
            if (!Array.isArray(app.state.requestMemory.entries)) app.state.requestMemory.entries = [];
          }
          return;
        }
        const parsed = parseJSON(raw, null);
        if (!parsed || typeof parsed !== 'object') return;

        app.state = {
          ...structuredClone(DEFAULT_STATE),
          ...parsed,
          requestMemory: {
            ...structuredClone(DEFAULT_REQUEST_MEMORY),
            ...(memoryParsed || parsed.requestMemory || {})
          },
          settings: {
            ...structuredClone(DEFAULT_STATE.settings),
            ...(parsed.settings || {}),
            ilias: {
              ...structuredClone(DEFAULT_STATE.settings.ilias),
              ...((parsed.settings && parsed.settings.ilias) || {})
            },
            fastMode: {
              ...structuredClone(DEFAULT_STATE.settings.fastMode),
              ...((parsed.settings && parsed.settings.fastMode) || {})
            },
            compareMode: {
              ...structuredClone(DEFAULT_STATE.settings.compareMode),
              ...((parsed.settings && parsed.settings.compareMode) || {})
            },
            mobileReader: {
              ...structuredClone(DEFAULT_STATE.settings.mobileReader),
              ...((parsed.settings && parsed.settings.mobileReader) || {})
            },
            prompting: {
              ...structuredClone(DEFAULT_STATE.settings.prompting),
              ...((parsed.settings && parsed.settings.prompting) || {})
            },
            cardsWebhook: {
              ...structuredClone(DEFAULT_STATE.settings.cardsWebhook),
              ...((parsed.settings && parsed.settings.cardsWebhook) || {})
            },
            sources: {
              ...structuredClone(DEFAULT_STATE.settings.sources),
              ...((parsed.settings && parsed.settings.sources) || {})
            }
          },
          sessions: Array.isArray(parsed.sessions) ? parsed.sessions : []
        };

        app.state.version = APP_VERSION;
        app.state.isSending = false;
        app.state.requestController = null;
        app.state.requestMemory.maxEntries = Math.max(30, Number(app.state.requestMemory.maxEntries) || 120);
        if (!Array.isArray(app.state.requestMemory.entries)) app.state.requestMemory.entries = [];
        if (!app.state.keywordLinks || typeof app.state.keywordLinks !== 'object') {
          app.state.keywordLinks = structuredClone(DEFAULT_DIRECTORY_LINKS);
        }
        if (String(app.state.settings.domain || '').toUpperCase() === 'IT') {
          app.state.settings.domain = '';
        }

        const newWelcome =
          'Willkommen bei **LINDA**.\n\n' +
          'Ich unterstütze dich bei **AEVO**, **BWL/VWL** und **Personalwesen**.\n' +
          'Lernkarten werden aus den **Inhalten der Antwort** erstellt.\n' +
          'ILIAS kann bei Bedarf über den Schalter **Kursraum (ILIAS)** aktiviert werden.';

        app.state.sessions.forEach((session) => {
          (session.messages || []).forEach((msg) => {
            if (msg.role !== 'assistant') return;
            const txt = String(msg.content || '');
            if (/willkommen bei\s*\*?\*?linda3/i.test(txt)) msg.content = newWelcome;
            if (/willkommen bei\s*\*?\*?linda/i.test(txt)) app.state.welcomeShown = true;
          });
        });
      },
      sanitizeLinks: (root) => {
        root.querySelectorAll('a').forEach((a) => {
          const href = String(a.getAttribute('href') || '').trim();
          if (!/^https?:\/\//i.test(href)) a.removeAttribute('href');
          a.setAttribute('target', '_blank');
          a.setAttribute('rel', 'noopener noreferrer nofollow');
        });
      },
      activeSources: () => {
        const sources = app.state.settings.sources || {};
        return Object.entries(sources).filter(([, on]) => Boolean(on)).map(([k]) => k);
      },
      chatContext: (session) => {
        return (session?.messages || [])
          .slice(-6)
          .filter((m) => !/willkommen/i.test(m.content || ''))
          .map((m) => ({ role: m.role, content: app.utils.truncate(m.content, 700) }));
      },
      parseApiAnswer: (rawText) => {
        const parsed = parseJSON(rawText, null);
        if (!parsed) return { answer: rawText, sources: [] };
        if (typeof parsed === 'string') return { answer: parsed, sources: [] };
        const altSources =
          parsed.sources ||
          parsed.quellen ||
          parsed.references ||
          parsed.citations ||
          parsed.links ||
          (parsed.metadata && parsed.metadata.sources) ||
          [];
        return {
          answer: String(parsed.answer || parsed.response || parsed.text || parsed.output || rawText),
          sources: Array.isArray(altSources) ? altSources : []
        };
      },
      nowStamp: () => new Date().toLocaleString('de-DE'),
      getPromptingConfig: () => {
        const cfg = app.state.settings.prompting?.config;
        if (!cfg || typeof cfg !== 'object') return structuredClone(DEFAULT_PROMPTING_JSON);
        return {
          ...structuredClone(DEFAULT_PROMPTING_JSON),
          ...cfg
        };
      },
      isMobileClient: () => /iphone|ipad|ipod|android|mobile/i.test(navigator.userAgent || '')
    },

    ui: {
      log: document.getElementById('chat-log'),
      input: document.getElementById('chat-input'),
      sendBtn: document.getElementById('send-btn'),

      openModal: (id) => {
        document.querySelectorAll('.modal-overlay').forEach((m) => m.classList.remove('open'));
        const modal = document.getElementById(id);
        if (!modal) return;
        modal.classList.add('open');

        if (id === 'modal-settings') {
          app.ui.fillSettingsForm();
          app.ui.renderSourceToggleList();
          app.ui.renderSnippetList();
        }
        if (id === 'modal-sessions') app.ui.renderSessionList();
      },

      closeModals: () => {
        document.querySelectorAll('.modal-overlay').forEach((m) => m.classList.remove('open'));
      },

      fillSettingsForm: () => {
        const { settings } = app.state;
        document.getElementById('inp-name').value = settings.name || '';
        document.getElementById('inp-domain').value = settings.domain || '';
        document.getElementById('inp-prompting-enabled').checked = Boolean(settings.prompting && settings.prompting.enabled);
        document.getElementById('inp-prompting-json').value = JSON.stringify(
          app.utils.getPromptingConfig(),
          null,
          2
        );
        document.getElementById('inp-cards-webhook-json').value = JSON.stringify(
          app.state.settings.cardsWebhook || DEFAULT_CARDS_WEBHOOK_JSON,
          null,
          2
        );
        app.ui.renderApiHealthStatus(app.state.apiHealth);
      },

      renderApiHealthStatus: (health) => {
        const box = document.getElementById('api-health-status');
        if (!box) return;
        const h = (health && typeof health === 'object') ? health : null;
        if (!h || !h.checks || typeof h.checks !== 'object' || !Object.keys(h.checks).length) {
          box.textContent = 'Noch nicht geprüft.';
          box.style.color = '#37526f';
          return;
        }
        const lines = [];
        lines.push(`Status: ${h.ok ? 'OK' : 'Unvollständig'}`);
        Object.entries(h.checks).forEach(([k, v]) => {
          lines.push(`${v ? '✓' : '✗'} ${k}`);
        });
        if (h.ts) {
          const ts = new Date(h.ts);
          if (!Number.isNaN(ts.getTime())) lines.push(`Geprüft: ${ts.toLocaleString('de-DE')}`);
        }
        box.textContent = lines.join('\n');
        box.style.color = h.ok ? '#1f6b2a' : '#8a3b00';
      },

      syncFastModeControls: () => {
        const fastEnabled = Boolean(app.state.settings.fastMode && app.state.settings.fastMode.enabled);
        const on = document.getElementById('fastmode-main-on');
        const off = document.getElementById('fastmode-main-off');
        if (on) on.checked = fastEnabled;
        if (off) off.checked = !fastEnabled;
      },

      syncCompareModeControls: () => {
        const compareEnabled = Boolean(app.state.settings.compareMode && app.state.settings.compareMode.enabled);
        const on = document.getElementById('compare-main-on');
        const off = document.getElementById('compare-main-off');
        if (on) on.checked = compareEnabled;
        if (off) off.checked = !compareEnabled;
      },

      syncLearningDirectoryControls: () => {
        const enabled = Boolean(app.state.settings.sources && app.state.settings.sources.directory);
        const on = document.getElementById('directory-main-on');
        const off = document.getElementById('directory-main-off');
        if (on) on.checked = enabled;
        if (off) off.checked = !enabled;
      },

      syncMobileReaderControls: () => {
        const enabled = Boolean(app.state.settings.mobileReader && app.state.settings.mobileReader.enabled);
        const on = document.getElementById('mobile-reader-on');
        const off = document.getElementById('mobile-reader-off');
        if (on) on.checked = enabled;
        if (off) off.checked = !enabled;
      },

      applyMobileReaderClass: () => {
        const mobileClient = app.utils.isMobileClient();
        const enabled = mobileClient && Boolean(app.state.settings.mobileReader && app.state.settings.mobileReader.enabled);
        document.body.classList.toggle('mobile-reader', enabled);
      },

      renderSourceToolbar: () => {
        const bar = document.getElementById('source-toolbar');
        const active = app.state.settings.sources || {};
        bar.innerHTML = SOURCE_DEFS.map((src) => {
          const on = Boolean(active[src.key]);
          return `
            <label class="source-chip ${on ? 'on' : ''}" data-source-chip="${src.key}">
              <input type="checkbox" data-source-cb="${src.key}" ${on ? 'checked' : ''}>
              <span>${src.label}</span>
            </label>
          `;
        }).join('');
      },

      renderSourceToggleList: () => {
        const wrap = document.getElementById('source-toggle-list');
        const active = app.state.settings.sources || {};
        wrap.innerHTML = SOURCE_DEFS.map((src) => `
          <div class="toggle-row">
            <label for="src-${src.key}">${src.label}</label>
            <input id="src-${src.key}" type="checkbox" data-source-setting="${src.key}" ${active[src.key] ? 'checked' : ''}>
          </div>
        `).join('');
      },

      renderSessionList: () => {
        const list = document.getElementById('session-list');
        const sessions = (app.state.sessions || []).slice(0, 12);
        if (!sessions.length) {
          list.innerHTML = '<div class="list-item"><span>Keine Verläufe vorhanden.</span></div>';
          return;
        }
        list.innerHTML = sessions.map((s) => `
          <div class="list-item ${s.id === app.state.activeId ? 'active' : ''}" data-session-id="${s.id}">
            <span style="overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${app.utils.safeText(s.name || 'Neuer Chat')}</span>
            <span class="mini">${new Date(s.ts).toLocaleDateString('de-DE')}</span>
          </div>
        `).join('');
      },

      renderSnippetList: () => {
        const container = document.getElementById('snippet-list-container');
        const snippets = app.state.settings.snippets || [];
        if (!snippets.length) {
          container.innerHTML = '<span class="mini">Keine Snippets hinterlegt.</span>';
          return;
        }
        container.innerHTML = snippets.map((txt, i) => `
          <span style="display:inline-flex;align-items:center;gap:6px;background:#edf4ff;border:1px solid #d4e2f6;padding:4px 8px;border-radius:999px;font-size:0.8rem;">
            ${app.utils.safeText(txt)}
            <button type="button" data-remove-snippet="${i}" style="border:none;background:none;color:#9c1f2e;cursor:pointer;font-size:0.9rem;">×</button>
          </span>
        `).join('');
      },

      showSnippetPopup: (items) => {
        const pop = document.getElementById('snippet-popup');
        if (!items.length) {
          pop.classList.remove('active');
          pop.innerHTML = '';
          return;
        }
        pop.innerHTML = items
          .map((item) => {
            const entry = (typeof item === 'string')
              ? { label: item, value: item }
              : { label: item.label || item.value || '', value: item.value || '', kind: item.kind || '' };
            return `
              <div class="snippet-item" data-snippet="${encodeURIComponent(entry.value)}">
                <div>${app.utils.safeText(entry.label)}</div>
                ${entry.kind ? `<div class="mini" style="margin-top:3px;">${app.utils.safeText(entry.kind)}</div>` : ''}
              </div>
            `;
          })
          .join('');
        pop.classList.add('active');
      },

      createBubble: (role, content, sources = []) => {
        const row = document.createElement('div');
        row.className = `msg-row ${role}`;

        if (role === 'user') {
          row.innerHTML = `
            <div class="msg-wrap">
              <div class="bubble user"><div class="md">${app.utils.safeText(content)}</div></div>
            </div>
          `;
          return row;
        }

        const mdRaw = marked.parse(String(content).replace(/\$(.*?)\$/g, '**$1**'));
        const safe = DOMPurify.sanitize(mdRaw, {
          ALLOWED_TAGS: ['p','br','strong','em','ul','ol','li','h1','h2','h3','h4','h5','pre','code','blockquote','table','thead','tbody','tr','th','td','a'],
          ALLOWED_ATTR: ['href','target','rel']
        });
        const plainContent = String(content || '');
        const hasJudgmentSignal =
          /(?:\burteil(?:e|en)?\b|\bbeschluss(?:e|es|en)?\b|\baktenzeichen\b|\baz\.\s*[:\-]?)/i.test(plainContent);
        const disclaimerHtml = hasJudgmentSignal
          ? '<div class="case-disclaimer"><strong>Wichtiger Hinweis:</strong> Urteile (insbesondere Aktenzeichen und Inhalte) müssen immer zwingend im Original überprüft werden.</div>'
          : '';

        row.innerHTML = `
          <div class="msg-wrap">
            <div class="bubble assistant"><div class="md">${safe}</div>${disclaimerHtml}</div>
            <div class="msg-actions">
              <button class="action-btn strong" data-action="copy">Kopieren</button>
              <button class="action-btn" data-action="share">Teilen</button>
              <button class="action-btn" data-action="pdf">PDF</button>
              <button class="action-btn" data-action="feedback">Feedback</button>
            </div>
          </div>
        `;

        const md = row.querySelector('.md');
        app.utils.sanitizeLinks(md);
        app.logic.decorateBubble(md, sources);
        return row;
      },

      createCompareBubble: (makeData, deepseekData) => {
        const row = document.createElement('div');
        row.className = 'msg-row assistant';

        const renderSection = (title, data) => {
          const answer = String(data?.answer || '');
          const mdRaw = marked.parse(answer.replace(/\$(.*?)\$/g, '**$1**'));
          const safe = DOMPurify.sanitize(mdRaw, {
            ALLOWED_TAGS: ['p','br','strong','em','ul','ol','li','h1','h2','h3','h4','h5','pre','code','blockquote','table','thead','tbody','tr','th','td','a'],
            ALLOWED_ATTR: ['href','target','rel']
          });
          const hasJudgmentSignal = /(?:\burteil(?:e|en)?\b|\bbeschluss(?:e|es|en)?\b|\baktenzeichen\b|\baz\.\s*[:\-]?)/i.test(answer);
          const disclaimerHtml = hasJudgmentSignal
            ? '<div class="case-disclaimer"><strong>Wichtiger Hinweis:</strong> Urteile (insbesondere Aktenzeichen und Inhalte) müssen immer zwingend im Original überprüft werden.</div>'
            : '';
          return `
            <section class="compare-col">
              <div class="compare-col-head">${app.utils.safeText(title)}</div>
              <div class="md">${safe}</div>
              ${disclaimerHtml}
            </section>
          `;
        };

        row.innerHTML = `
          <div class="msg-wrap">
            <div class="bubble assistant">
              <div class="compare-canvas">
                ${renderSection('Linda 3.0', makeData)}
                ${renderSection('Schnellmodus', deepseekData)}
              </div>
            </div>
          </div>
        `;

        const cols = row.querySelectorAll('.compare-col');
        if (cols[0]) {
          const md = cols[0].querySelector('.md');
          app.utils.sanitizeLinks(md);
          app.logic.decorateBubble(md, makeData?.sources || []);
        }
        if (cols[1]) {
          const md = cols[1].querySelector('.md');
          app.utils.sanitizeLinks(md);
          app.logic.decorateBubble(md, deepseekData?.sources || []);
        }
        return row;
      },

      setSendingState: (sending) => {
        app.state.isSending = sending;
        app.ui.input.disabled = sending;
        app.ui.sendBtn.classList.toggle('stop', sending);
        app.ui.sendBtn.textContent = sending ? '■' : '➤';
      },

      scrollBottom: () => {
        requestAnimationFrame(() => {
          app.ui.log.scrollTop = app.ui.log.scrollHeight;
        });
      },

      syncViewportInsets: () => {
        if (!window.visualViewport) return;
        const vv = window.visualViewport;
        const kb = Math.max(0, window.innerHeight - vv.height - vv.offsetTop);
        document.documentElement.style.setProperty('--kb', kb + 'px');
      },

      updateDomainUI: () => {
        const domain = app.state.settings.domain || 'Standard';
        const activeCount = app.utils.activeSources().length;
        const isFast = Boolean(app.state.settings.fastMode && app.state.settings.fastMode.enabled);
        const isCompare = Boolean(app.state.settings.compareMode && app.state.settings.compareMode.enabled);
        const hasDirectory = Boolean(app.state.settings.sources && app.state.settings.sources.directory);
        document.getElementById('domain-badge').textContent = isFast ? `${domain} ⚡` : domain;
        document.getElementById('domain-summary').textContent = `Fachmodus: ${domain}${isFast ? ' • Schnellmodus aktiv' : ''}${isCompare ? ' • Vergleich aktiv' : ''}${hasDirectory ? ' • Lernverzeichnis (Beta) aktiv' : ''} • Wissensbereiche: ${activeCount} aktiv`;
      },

      loadingRow: () => {
        const row = document.createElement('div');
        row.className = 'msg-row assistant';
        row.innerHTML = '<div class="msg-wrap"><div class="bubble assistant"><div class="loading"><span></span><span></span><span></span></div></div></div>';
        return row;
      },

      hideSelectionMenu: () => {
        const menu = document.getElementById('selection-menu');
        menu.classList.remove('active');
      },

      showSelectionMenu: (x, y) => {
        const menu = document.getElementById('selection-menu');
        const draft = app.state.selectionDraft || {};
        const len = Number(draft.textLength || 0);
        const canCards = len >= 24;
        const canPractice = len >= 40;
        const canTranslate = len > 0 && len <= 250;
        const canRewrite = len > 0 && len <= 500;

        const cardsBtn = document.getElementById('selection-cards-btn');
        const practiceBtn = document.getElementById('selection-practice-btn');
        const translateBtn = document.getElementById('selection-translate-btn');
        const rewriteBtn = document.getElementById('selection-rewrite-btn');
        const note = document.getElementById('selection-note');

        if (cardsBtn) cardsBtn.disabled = !canCards;
        if (practiceBtn) practiceBtn.disabled = !canPractice;
        if (translateBtn) translateBtn.disabled = !canTranslate;
        if (rewriteBtn) rewriteBtn.disabled = !canRewrite;
        if (note) {
          note.textContent =
            `Zeichen: ${len} • Uebungsaufgaben ab 40 • Uebersetzen bis 250 • Komprimieren bis 500 • Lernkarten ab 24`;
        }

        const vw = window.innerWidth;
        const vh = window.innerHeight;
        const left = Math.min(Math.max(8, x), vw - 250);
        const top = Math.min(Math.max(8, y), vh - 80);
        menu.style.left = `${left}px`;
        menu.style.top = `${top}px`;
        menu.classList.add('active');
      },

      openSelectionActionModal: ({ title, preview, fieldsHtml, confirmLabel, onConfirm }) => {
        const modal = document.getElementById('selection-action-modal');
        const titleEl = document.getElementById('selection-action-title');
        const previewEl = document.getElementById('selection-action-preview');
        const fieldsEl = document.getElementById('selection-action-fields');
        const confirmBtn = document.getElementById('selection-action-confirm');
        const cancelBtn = document.getElementById('selection-action-cancel');

        titleEl.textContent = title || 'Aktion';
        previewEl.textContent = preview || '';
        fieldsEl.innerHTML = fieldsHtml || '';
        confirmBtn.textContent = confirmLabel || 'Ausführen';

        const close = () => {
          modal.classList.remove('open');
          modal.setAttribute('aria-hidden', 'true');
          confirmBtn.onclick = null;
        };

        cancelBtn.onclick = close;
        modal.onclick = (evt) => {
          if (evt.target === modal) close();
        };

        confirmBtn.onclick = async () => {
          confirmBtn.disabled = true;
          try {
            await onConfirm();
            close();
          } catch (err) {
            alert(`Aktion fehlgeschlagen: ${err?.message || 'unbekannt'}`);
          } finally {
            confirmBtn.disabled = false;
          }
        };

        modal.classList.add('open');
        modal.setAttribute('aria-hidden', 'false');
      },

      openSelectionResultModal: (title, text, opts = {}) => {
        const modal = document.getElementById('selection-result-modal');
        const titleEl = document.getElementById('selection-result-title');
        const textEl = document.getElementById('selection-result-text');
        const speakBtn = document.getElementById('selection-result-speak');
        titleEl.textContent = title || 'Ergebnis';
        textEl.value = String(text || '');
        modal.dataset.speechLang = String(opts.lang || navigator.language || 'de-DE');
        modal.dataset.speechEnabled = String(Boolean(opts.allowSpeech !== false));
        modal.dataset.speechPreferApi = String(Boolean(opts.preferApiTts !== false));
        modal.dataset.speechVoice = String(opts.voice || 'alloy');
        modal.dataset.speechSpeed = String(Number(opts.speed || 1));
        if (speakBtn) {
          const supported = app.logic.isSpeechSupported();
          const hasText = String(text || '').trim().length > 0;
          speakBtn.disabled = !supported || !hasText || modal.dataset.speechEnabled === 'false';
          speakBtn.textContent = 'Vorlesen';
        }
        modal.classList.add('open');
        modal.setAttribute('aria-hidden', 'false');
      },

      closeSelectionResultModal: () => {
        const modal = document.getElementById('selection-result-modal');
        app.logic.stopSpeech();
        const speakBtn = document.getElementById('selection-result-speak');
        if (speakBtn) speakBtn.textContent = 'Vorlesen';
        modal.classList.remove('open');
        modal.setAttribute('aria-hidden', 'true');
      },

      renderModeCards: () => {
        const cfg = app.utils.getPromptingConfig();
        const cards = Array.isArray(cfg.modeCards) ? cfg.modeCards : [];
        if (!cards.length) return null;

        const row = document.createElement('div');
        row.className = 'msg-row assistant mode-card-row';
        row.innerHTML = `
          <div class="msg-wrap">
            <div class="mode-card">
              <h4>Fachmodus auswählen</h4>
              <p>Du hast noch keinen Fachmodus gewählt. Tippe auf eine Karte, um den Chat direkt anzupassen.</p>
              <div class="mode-grid">
                ${cards.map((c) => `<button class="mode-btn" data-set-domain="${app.utils.safeText(c.key)}">${app.utils.safeText(c.label)}${c.hint ? ` - ${app.utils.safeText(c.hint)}` : ''}</button>`).join('')}
              </div>
            </div>
          </div>
        `;
        return row;
      }
    },

    logic: {
      activeSession: () => app.state.sessions.find((s) => s.id === app.state.activeId),

      ensureSession: () => {
        if (app.state.sessions.length && app.state.activeId) return;
        app.logic.newChat();
      },

      isMobileReaderEnabled: () => {
        return Boolean(
          app.utils.isMobileClient() &&
          app.state.settings.mobileReader &&
          app.state.settings.mobileReader.enabled
        );
      },

      setMobileReader: (enabled) => {
        app.state.settings.mobileReader.enabled = Boolean(enabled);

        if (app.logic.isMobileReaderEnabled()) {
          app.state.settings.fastMode.enabled = false;
          app.state.settings.compareMode.enabled = false;
          app.state.settings.sources = {
            ...app.state.settings.sources,
            ...MAKEFLOW_ONLY_SOURCES
          };
          app.state.settings.ilias.enabled = false;
        }

        app.ui.syncMobileReaderControls();
        app.ui.syncFastModeControls();
        app.ui.syncCompareModeControls();
        app.ui.syncLearningDirectoryControls();
        app.ui.renderSourceToolbar();
        app.ui.updateDomainUI();
        app.ui.applyMobileReaderClass();
        app.utils.save();
      },

      loadKeywordLinks: async () => {
        try {
          const res = await fetch(DIRECTORY_LINKS_PATH, { cache: 'no-store' });
          if (!res.ok) return;
          const parsed = await res.json();
          if (!parsed || typeof parsed !== 'object') return;

          const out = {
            version: String(parsed.version || '1.0'),
            description: String(parsed.description || ''),
            entries: []
          };

          // New format: { entries: [{ title, url, keywords: [] }] }
          if (Array.isArray(parsed.entries)) {
            out.entries = parsed.entries
              .map((entry) => {
                if (!entry || typeof entry !== 'object') return null;
                const title = String(entry.title || '').trim();
                const url = String(entry.url || '').trim();
                const note = String(entry.note || '').trim();
                const enabled = entry.enabled !== false;
                const keywords = (Array.isArray(entry.keywords) ? entry.keywords : [])
                  .map((k) => app.utils.normalizeForKeyword(k))
                  .filter(Boolean);
                if (!title || !url || !keywords.length) return null;
                return { title, url, note, enabled, keywords };
              })
              .filter(Boolean);
          }

          // Legacy migration: { keywords: { "term": [ {title,url,note} ] } }
          if (!out.entries.length && parsed.keywords && typeof parsed.keywords === 'object') {
            const migrated = [];
            Object.entries(parsed.keywords).forEach(([keyword, links]) => {
              const normalizedKeyword = app.utils.normalizeForKeyword(keyword);
              if (!normalizedKeyword) return;
              (Array.isArray(links) ? links : []).forEach((item) => {
                if (!item || typeof item !== 'object') return;
                const title = String(item.title || item.name || '').trim();
                const url = String(item.url || '').trim();
                const note = String(item.note || '').trim();
                if (!title || !url) return;
                migrated.push({
                  title,
                  url,
                  note,
                  enabled: true,
                  keywords: [normalizedKeyword]
                });
              });
            });

            const merged = new Map();
            migrated.forEach((entry) => {
              const key = `${entry.title}|${entry.url}`.toLowerCase();
              const prev = merged.get(key);
              if (!prev) {
                merged.set(key, { ...entry });
                return;
              }
              const kw = new Set([...(prev.keywords || []), ...(entry.keywords || [])]);
              prev.keywords = Array.from(kw);
            });
            out.entries = Array.from(merged.values());
          }

          app.state.keywordLinks = out;
        } catch (_) {}
      },

      loadLearningTemplates: async () => {
        try {
          const res = await fetch(LEARNING_TEMPLATES_PATH, { cache: 'no-store' });
          if (!res.ok) return;
          const parsed = await res.json();
          if (!parsed || typeof parsed !== 'object') return;

          const flashInstruction = String(parsed?.flashcards?.instruction_template || '').trim();
          const practiceObj = parsed?.practice && typeof parsed.practice === 'object' ? parsed.practice : {};
          const practiceTemplates = Array.isArray(practiceObj.templates) ? practiceObj.templates : [];
          const normalizedTemplates = practiceTemplates
            .map((t) => {
              if (!t || typeof t !== 'object') return null;
              const id = String(t.id || '').trim();
              const label = String(t.label || '').trim();
              if (!id || !label) return null;
              return {
                id,
                label,
                description: String(t.description || '').trim(),
                duration: String(t.duration || '').trim(),
                default_count: Math.max(3, Math.min(12, Number(t.default_count || 6))),
                supports_open: Boolean(t.supports_open)
              };
            })
            .filter(Boolean);

          learningTemplatesCache = {
            version: String(parsed.version || DEFAULT_LEARNING_TEMPLATES.version || '1.0'),
            flashcards: {
              instruction_template:
                flashInstruction || DEFAULT_LEARNING_TEMPLATES.flashcards.instruction_template
            },
            practice: {
              title_prefix: String(practiceObj.title_prefix || DEFAULT_LEARNING_TEMPLATES.practice.title_prefix || 'Uebungsaufgaben').trim(),
              instruction_template:
                String(practiceObj.instruction_template || '').trim() ||
                DEFAULT_LEARNING_TEMPLATES.practice.instruction_template,
              templates: normalizedTemplates.length
                ? normalizedTemplates
                : structuredClone(DEFAULT_LEARNING_TEMPLATES.practice.templates),
              difficulties: (Array.isArray(practiceObj.difficulties) ? practiceObj.difficulties : [])
                .map((v) => String(v || '').trim())
                .filter(Boolean)
            }
          };
          if (!learningTemplatesCache.practice.difficulties.length) {
            learningTemplatesCache.practice.difficulties = structuredClone(DEFAULT_LEARNING_TEMPLATES.practice.difficulties);
          }
        } catch (_) {}
      },

      getLearningTemplates: () => {
        return learningTemplatesCache || structuredClone(DEFAULT_LEARNING_TEMPLATES);
      },

      fillTemplateVars: (template, vars) => {
        let out = String(template || '');
        Object.entries(vars || {}).forEach(([k, v]) => {
          const rx = new RegExp(`{{\\s*${k}\\s*}}`, 'g');
          out = out.replace(rx, String(v == null ? '' : v));
        });
        return out;
      },

      checkApiHealth: async () => {
        const box = document.getElementById('api-health-status');
        if (box) {
          box.textContent = 'Prüfe API-Konfiguration...';
          box.style.color = '#37526f';
        }
        try {
          const res = await fetch(HEALTH_API_ENDPOINT, { method: 'GET' });
          const raw = await res.text();
          let parsed = {};
          try { parsed = JSON.parse(raw); } catch (_) {}
          if (!res.ok) throw new Error(parsed?.error || `HTTP ${res.status}`);

          app.state.apiHealth = {
            ok: Boolean(parsed?.ok),
            checks: (parsed?.checks && typeof parsed.checks === 'object') ? parsed.checks : {},
            ts: String(parsed?.ts || new Date().toISOString())
          };
          app.ui.renderApiHealthStatus(app.state.apiHealth);
          app.utils.save();
        } catch (e) {
          app.state.apiHealth = {
            ok: false,
            checks: {},
            ts: new Date().toISOString(),
            error: String(e?.message || 'unbekannt')
          };
          if (box) {
            box.textContent = `Health-Check fehlgeschlagen: ${app.state.apiHealth.error}`;
            box.style.color = '#8a3b00';
          }
        }
      },

      findKeywordLinks: (text) => {
        if (!DIRECTORY_KEYWORD_MATCHING_ENABLED) return [];
        const enabled = Boolean(app.state.settings.sources && app.state.settings.sources.directory);
        if (!enabled) return [];
        const cfg = app.state.keywordLinks || {};
        const entries = Array.isArray(cfg.entries) ? cfg.entries : [];
        const rawText = app.utils.normalizeForKeyword(text);
        if (!rawText) return [];

        const links = [];
        const seen = new Set();
        entries.forEach((entry) => {
          if (!entry || entry.enabled === false) return;
          const keywords = (Array.isArray(entry.keywords) ? entry.keywords : [])
            .map((k) => app.utils.normalizeForKeyword(k))
            .filter(Boolean);
          if (!keywords.length) return;
          const matched = keywords.some((k) => rawText.includes(k));
          if (!matched) return;
          const title = String(entry.title || '').trim();
          const url = String(entry.url || '').trim();
          const note = String(entry.note || '').trim();
          if (!title || !url) return;
          const key = `${title}|${url}`.toLowerCase();
          if (seen.has(key)) return;
          seen.add(key);
          links.push({ title, url, note });
        });
        return links.slice(0, 8);
      },

      startApp: () => {
        const c1 = document.getElementById('consent-data').checked;
        const c2 = document.getElementById('consent-forward').checked;
        if (!c1 || !c2) {
          alert('Bitte beide Zustimmungen aktivieren.');
          return;
        }
        app.state.consentGiven = true;
        app.utils.save();
        app.ui.closeModals();
        app.logic.ensureSession();
        setTimeout(() => app.ui.input.focus(), 80);
      },

      sendSystemMessage: (text) => {
        const s = app.logic.activeSession();
        if (!s) return;
        s.messages.push({ role: 'assistant', content: text, sources: [] });
        app.utils.save();
        const bubble = app.ui.createBubble('assistant', text);
        app.ui.log.appendChild(bubble);
        app.ui.scrollBottom();
      },

      newChat: () => {
        const id = app.utils.uid();
        app.state.sessions.unshift({
          id,
          name: 'Neuer Chat',
          ts: app.utils.now(),
          messages: []
        });
        app.state.activeId = id;
        app.ui.log.innerHTML = '';
        app.utils.save();
        app.ui.closeModals();

        if (!app.state.welcomeShown) {
          app.logic.sendSystemMessage(
            'Willkommen bei **LINDA**.\n\n' +
            'Ich unterstütze dich bei **AEVO**, **BWL/VWL** und **Personalwesen**.\n' +
            'Lernkarten werden aus den **Inhalten der Antwort** erstellt.\n' +
            'ILIAS kann bei Bedarf über den Schalter **Kursraum (ILIAS)** aktiviert werden.'
          );
          app.state.welcomeShown = true;
          app.utils.save();
        }
        app.logic.maybeShowModeCards();
      },

      switchSession: (id) => {
        app.state.activeId = id;
        app.ui.log.innerHTML = '';
        app.utils.save();
        app.ui.closeModals();

        const s = app.logic.activeSession();
        if (!s) return;

        s.messages.forEach((m) => {
          if (m.role === 'assistant' && m.compare && typeof m.compare === 'object') {
            app.ui.log.appendChild(
              app.ui.createCompareBubble(
                m.compare.make || { answer: '' },
                m.compare.deepseek || { answer: '' }
              )
            );
            return;
          }
          const bubble = app.ui.createBubble(m.role, m.content, m.sources || []);
          app.ui.log.appendChild(bubble);
        });

        app.logic.maybeShowModeCards();
        app.ui.scrollBottom();
      },

      saveSettings: () => {
        app.state.settings.name = document.getElementById('inp-name').value.trim();
        app.state.settings.domain = document.getElementById('inp-domain').value;

        app.state.settings.ilias.enabled = Boolean(app.state.settings.sources.ilias);
        app.state.settings.prompting.enabled = document.getElementById('inp-prompting-enabled').checked;

        try {
          const rawCfg = document.getElementById('inp-prompting-json').value.trim();
          const parsedCfg = rawCfg ? JSON.parse(rawCfg) : structuredClone(DEFAULT_PROMPTING_JSON);
          app.state.settings.prompting.config = parsedCfg;
        } catch (_) {
          alert('Prompting-JSON ist ungültig. Bitte prüfen.');
          return;
        }

        try {
          const rawCardsCfg = document.getElementById('inp-cards-webhook-json').value.trim();
          const parsedCardsCfg = rawCardsCfg ? JSON.parse(rawCardsCfg) : structuredClone(DEFAULT_CARDS_WEBHOOK_JSON);
          app.state.settings.cardsWebhook = parsedCardsCfg;
        } catch (_) {
          alert('Lernkarten-Webhook-JSON ist ungültig. Bitte prüfen.');
          return;
        }

        document.querySelectorAll('[data-source-setting]').forEach((cb) => {
          const key = cb.getAttribute('data-source-setting');
          app.state.settings.sources[key] = cb.checked;
        });

        app.state.settings.ilias.enabled = Boolean(app.state.settings.sources.ilias);

        app.utils.save();
        app.ui.updateDomainUI();
        app.ui.renderSourceToolbar();
        app.ui.syncLearningDirectoryControls();
        app.ui.closeModals();
        app.logic.maybeShowModeCards();
      },

      addSnippet: () => {
        const inp = document.getElementById('inp-snippet');
        const val = inp.value.trim();
        if (!val) return;
        app.state.settings.snippets.push(val);
        inp.value = '';
        app.utils.save();
        app.ui.renderSnippetList();
      },

      removeSnippet: (idx) => {
        app.state.settings.snippets.splice(idx, 1);
        app.utils.save();
        app.ui.renderSnippetList();
      },

      insertSnippet: (txt) => {
        app.ui.input.value = txt;
        app.ui.input.dispatchEvent(new Event('input'));
        document.getElementById('snippet-popup').classList.remove('active');
        app.ui.input.focus();
      },

      rememberQuestion: (text) => {
        const normalized = app.utils.normalizeQuestion(text);
        if (normalized.length < 4) return;

        const mem = app.state.requestMemory || (app.state.requestMemory = structuredClone(DEFAULT_REQUEST_MEMORY));
        const entries = Array.isArray(mem.entries) ? mem.entries : [];
        const now = app.utils.now();

        const idx = entries.findIndex((e) => e && e.normalized === normalized);
        if (idx >= 0) {
          const prev = entries[idx];
          entries[idx] = {
            ...prev,
            text: String(text || prev.text || '').trim() || prev.text,
            count: Number(prev.count || 0) + 1,
            lastUsed: now
          };
        } else {
          entries.push({
            text: String(text || '').trim(),
            normalized,
            count: 1,
            lastUsed: now
          });
        }

        entries.sort((a, b) => Number(b.lastUsed || 0) - Number(a.lastUsed || 0));
        mem.entries = entries.slice(0, mem.maxEntries || 120);
        mem.updatedAt = new Date(now).toISOString();
      },

      findQuestionSuggestions: (input, limit = 6) => {
        const raw = String(input || '').trim();
        if (raw.length < 3) return [];

        const inputNorm = app.utils.normalizeQuestion(raw);
        if (!inputNorm) return [];

        const mem = app.state.requestMemory;
        const entries = Array.isArray(mem?.entries) ? mem.entries : [];
        if (!entries.length) return [];

        const inputTokens = new Set(app.utils.questionTokens(inputNorm));
        const scored = [];

        entries.forEach((entry) => {
          if (!entry || !entry.text || !entry.normalized) return;
          let score = 0;
          const text = String(entry.text);
          const norm = String(entry.normalized);

          if (norm === inputNorm) score += 100;
          if (norm.includes(inputNorm) || inputNorm.includes(norm)) score += 45;
          if (text.toLowerCase().includes(raw.toLowerCase())) score += 20;

          const tokens = app.utils.questionTokens(norm);
          if (inputTokens.size && tokens.length) {
            const tokenSet = new Set(tokens);
            let overlap = 0;
            inputTokens.forEach((tok) => { if (tokenSet.has(tok)) overlap += 1; });
            if (overlap > 0) {
              const union = new Set([...inputTokens, ...tokenSet]).size || 1;
              score += Math.round((overlap / union) * 30);
            }
          }

          score += Math.min(Number(entry.count || 0), 10);
          if (score > 0) scored.push({ text, score, lastUsed: Number(entry.lastUsed || 0) });
        });

        scored.sort((a, b) => (b.score - a.score) || (b.lastUsed - a.lastUsed));

        const unique = [];
        const seen = new Set();
        scored.forEach((item) => {
          const key = item.text.toLowerCase();
          if (seen.has(key)) return;
          seen.add(key);
          unique.push(item.text);
        });

        return unique.slice(0, limit);
      },

      maybeShowModeCards: () => {
        if (app.state.settings.domain) return;
        const s = app.logic.activeSession();
        if (!s) return;
        const exists = app.ui.log.querySelector('.mode-card-row');
        if (exists) return;
        const row = app.ui.renderModeCards();
        if (!row) return;
        app.ui.log.appendChild(row);
        app.ui.scrollBottom();
      },

      getPromptingSuggestions: (inputValue) => {
        if (!app.state.settings.prompting?.enabled) return [];
        const text = String(inputValue || '');
        if (!text || text.startsWith('/')) return [];
        const cfg = app.utils.getPromptingConfig();
        const out = [];

        (Array.isArray(cfg.inlineExpansions) ? cfg.inlineExpansions : []).forEach((rule) => {
          try {
            const re = new RegExp(String(rule.pattern || ''), 'i');
            if (!re.test(text)) return;
            const value = text.replace(re, String(rule.replacement || ''));
            if (value !== text) out.push({ label: String(rule.replacement || value), value, kind: 'Prompting-Vorschlag' });
          } catch (_) {}
        });

        if (out.length) return out.slice(0, 6);

        if (text.length >= 6) {
          (Array.isArray(cfg.quickSuggestions) ? cfg.quickSuggestions : []).forEach((s) => {
            out.push({ label: s, value: `${text}\n\n${s}`, kind: 'Prompting-Vorschlag' });
          });
        }
        return out.slice(0, 6);
      },

      needsSlowModeHint: (text) => {
        const t = String(text || '').toLowerCase();
        const triggers = [
          'urteil',
          'beschwerde',
          'tieferes wissen',
          'mehr details',
          'verstehe ich nicht'
        ];
        return triggers.some((k) => t.includes(k));
      },

      openCardsTabWithPayload: (payload) => {
        localStorage.setItem(CARDS_KEY, JSON.stringify(payload));
        const target = `${window.location.pathname}?view=cards`;
        const tab = window.open(target, '_blank', 'noopener');
        if (!tab) alert('Popup blockiert. Bitte Popups erlauben, um Karten in neuem Tab zu öffnen.');
      },

      openPracticeTabWithPayload: (payload) => {
        localStorage.setItem(PRACTICE_KEY, JSON.stringify(payload));
        const target = `${window.location.pathname}?view=practice`;
        const tab = window.open(target, '_blank', 'noopener');
        if (!tab) alert('Popup blockiert. Bitte Popups erlauben, um Uebungsaufgaben in neuem Tab zu öffnen.');
      },

      prepareSelectionDraftFromEvent: (evt) => {
        const md = evt.target.closest('.msg-row.assistant .md');
        if (!md) return false;
        const sel = window.getSelection();
        if (!sel || sel.rangeCount === 0) return false;
        const txt = String(sel.toString() || '').trim();
        if (!txt || txt.length < 2) return false;
        if (!md.contains(sel.anchorNode) || !md.contains(sel.focusNode)) return false;
        app.state.selectionDraft = { text: txt, textLength: txt.length, ts: app.utils.now() };
        return true;
      },

      resolveSafeCardsEndpoint: () => {
        const cfg = app.state.settings.cardsWebhook || DEFAULT_CARDS_WEBHOOK_JSON;
        const raw = String(cfg.endpointPath || API_ENDPOINT || '/api/linda3?action=bot').trim();
        if (!raw) return '/api/linda3?action=bot';
        if (raw.startsWith('/')) {
          if (!raw.startsWith('/api/')) return '/api/linda3?action=bot';
          return raw;
        }
        try {
          const u = new URL(raw, window.location.origin);
          if (u.origin !== window.location.origin) return '/api/linda3?action=bot';
          if (!u.pathname.startsWith('/api/')) return '/api/linda3?action=bot';
          return `${u.pathname}${u.search}`;
        } catch (_) {
          return '/api/linda3?action=bot';
        }
      },

      sanitizeCardsInputText: (text, maxLen = 1400) => {
        return String(text || '')
          .replace(/\r/g, ' ')
          .replace(/[^\S\n]+/g, ' ')
          .replace(/\n{3,}/g, '\n\n')
          .trim()
          .slice(0, maxLen);
      },

      buildCardsWebhookQuestion: (text, targetCount, domain) => {
        const safeText = app.logic.sanitizeCardsInputText(text, 1400);
        const tpl = app.logic.getLearningTemplates();
        const pattern =
          String(tpl?.flashcards?.instruction_template || '').trim() ||
          DEFAULT_LEARNING_TEMPLATES.flashcards.instruction_template;
        return app.logic.fillTemplateVars(pattern, {
          count: targetCount,
          domain: domain || 'Standard',
          content: safeText
        });
      },

      requestCardsViaWebhook: async (rawText, sourceType = 'manual') => {
        const cfg = app.state.settings.cardsWebhook || DEFAULT_CARDS_WEBHOOK_JSON;
        const domain = app.state.settings.domain || '';
        const targetCount = Math.max(3, Math.min(24, Number(cfg.targetCount || 8)));
        const endpoint = app.logic.resolveSafeCardsEndpoint();
        const question = app.logic.buildCardsWebhookQuestion(rawText, targetCount, domain);

        const res = await fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            question: app.utils.truncate(question, 2400),
            fachmodus: domain,
            schnellmodus: Boolean(app.state.settings.fastMode && app.state.settings.fastMode.enabled),
            routing: {
              preferred_model: (app.state.settings.fastMode && app.state.settings.fastMode.enabled) ? 'Linda3Schnellmodus' : 'default'
            },
            history: []
          })
        });

        if (!res.ok) {
          let detail = '';
          try {
            const err = await res.json();
            const errMsg = String(err?.error || '').trim();
            const errDetail = String(err?.detail || '').trim();
            detail = errMsg ? `: ${errMsg}${errDetail ? ` (${errDetail})` : ''}` : '';
          } catch (_) {}
          throw new Error(`HTTP ${res.status}${detail}`);
        }

        const raw = await res.text();
        const parsed = parseCardsWebhookResponse(raw);
        const cards = (parsed?.cards || []).slice(0, targetCount);
        if (!cards.length) {
          const fallbackCards = app.logic.buildFlashcardsFromText(rawText).map((c) => ({
            ...c,
            id: hashCardId(c.question, c.answer),
            adaptive: { ease: 2, reps: 0, dueAt: 0 }
          }));
          return {
            deckTitle: 'Lernkarten',
            cards: fallbackCards.slice(0, targetCount),
            sourceType: `${sourceType}-local-fallback`
          };
        }
        return {
          deckTitle: parsed?.deckTitle || 'Lernkarten',
          cards,
          sourceType: `${sourceType}-webhook`
        };
      },

      requestAnswer: async (endpoint, payload, signal) => {
        const safeQuestion = String(
          payload?.question ||
          app.state?.lastQuestion ||
          ''
        ).trim();
        const safePayload = {
          ...(payload && typeof payload === 'object' ? payload : {}),
          question: app.utils.truncate(safeQuestion, 1300)
        };
        safePayload.prompt = safePayload.question;
        safePayload.input = safePayload.question;
        safePayload.text = safePayload.question;
        if (!safePayload.question) {
          throw new Error('Frage ist leer');
        }

        let res = await fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(safePayload),
          signal
        });

        if (!res.ok) {
          let detail = '';
          let errText = '';
          try {
            const err = await res.json();
            detail = err?.error ? `: ${err.error}` : '';
            errText = String(err?.error || err?.detail || '').toLowerCase();
          } catch (_) {}

          const missingQuestionError =
            res.status === 400 &&
            (errText.includes('question') || detail.toLowerCase().includes('question'));

          if (missingQuestionError) {
            const retryPayload = {
              question: safePayload.question,
              fachmodus: String(safePayload.fachmodus || ''),
              history: Array.isArray(safePayload.history) ? safePayload.history : [],
              routing: safePayload.routing || {}
            };
            res = await fetch(endpoint, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(retryPayload),
              signal
            });
          }
        }

        if (!res.ok) {
          let detail = '';
          try {
            const err = await res.json();
            detail = err?.error ? `: ${err.error}` : '';
          } catch (_) {}
          throw new Error(`HTTP ${res.status}${detail}`);
        }

        const raw = await res.text();
        return app.utils.parseApiAnswer(raw);
      },

      requestCardsFromSelection: async () => {
        const draft = app.state.selectionDraft;
        if (!draft || !draft.text) return;
        if (app.state.isCardsRequestRunning) return;
        if (String(draft.text || '').length < 24) {
          alert('Für Lernkarten bitte mindestens 24 Zeichen markieren.');
          return;
        }

        app.state.isCardsRequestRunning = true;
        app.ui.hideSelectionMenu();

        try {
          const result = await app.logic.requestSelectionFlashcards(draft.text);
          const cards = result.cards || [];

          app.logic.openCardsTabWithPayload({
            cards,
            generatedAt: app.utils.nowStamp(),
            sourceLength: draft.text.length,
            adaptive: true,
            deckTitle: result.deckTitle || 'Lernkarten aus Auswahl',
            sourceType: result.sourceType || 'selection-api'
          });
        } catch (e) {
          alert(`Lernkarten-Fehler: ${e.message || 'unbekannt'}`);
        } finally {
          app.state.isCardsRequestRunning = false;
        }
      },

      requestSelectionFlashcards: async (selectedText, count = 8) => {
        const domain = app.state.settings.domain || 'Standard';
        const safeCount = Math.max(4, Math.min(20, Number(count || 8)));
        const localFallback = () => {
          const cards = app.logic.buildFlashcardsFromText(selectedText)
            .slice(0, safeCount)
            .map((c) => ({
              ...c,
              id: hashCardId(c.question, c.answer),
              adaptive: { ease: 2, reps: 0, dueAt: 0 }
            }));

          if (!cards.length) throw new Error('Keine Lernkarten erzeugt');
          return {
            cards,
            deckTitle: 'Lernkarten aus Markierung',
            sourceType: 'selection-local-fallback'
          };
        };

        try {
          const res = await fetch(FLASHCARDS_API_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              title: `LINDA Auswahl ${domain}`,
              source: `Markierter Text (${domain})`,
              context: app.logic.sanitizeCardsInputText(selectedText, 1400),
              count: safeCount,
              economyMode: true
            })
          });

          if (!res.ok) return localFallback();

          const parsed = await res.json();
          const cards = (Array.isArray(parsed?.cards) ? parsed.cards : [])
            .map((c) => ({
              question: String(c.front || c.question || '').trim(),
              answer: String(c.back || c.answer || '').trim()
            }))
            .filter((c) => c.question && c.answer)
            .map((c) => ({
              ...c,
              id: hashCardId(c.question, c.answer),
              adaptive: { ease: 2, reps: 0, dueAt: 0 }
            }));

          if (!cards.length) return localFallback();
          return {
            cards,
            deckTitle: 'Lernkarten aus Markierung',
            sourceType: 'selection-flashcards-api'
          };
        } catch (_) {
          return localFallback();
        }
      },

      getPracticeTemplates: () => {
        const cfg = app.logic.getLearningTemplates();
        const fromCfg = Array.isArray(cfg?.practice?.templates) ? cfg.practice.templates : [];
        return fromCfg.length ? fromCfg : structuredClone(DEFAULT_LEARNING_TEMPLATES.practice.templates);
      },

      normalizePracticeSet: (data) => {
        const title = String(data?.title || '').trim() || 'Uebungsaufgaben';
        const questions = (Array.isArray(data?.questions) ? data.questions : [])
          .map((q, idx) => {
            const question = String(q?.question || '').trim();
            const type = String(q?.type || 'mc').toLowerCase();
            const options = (Array.isArray(q?.options) ? q.options : [])
              .map((o) => String(o || '').trim())
              .filter(Boolean)
              .slice(0, 6);
            const rawCorrect = Array.isArray(q?.correctIndices) ? q.correctIndices : [];
            const correctIndices = rawCorrect
              .map((v) => Number(v))
              .filter((v) => Number.isInteger(v) && v >= 0 && v < options.length)
              .slice(0, 2);
            const hint = String(q?.hint || '').trim();
            const solution = String(q?.solution || q?.answer || '').trim();
            const points = Math.max(1, Math.min(5, Number(q?.points || 2)));
            if (!question) return null;
            if (type === 'mc' && options.length < 2) return null;
            return {
              id: `p_${idx + 1}_${Date.now().toString(36)}`,
              type: type === 'open' ? 'open' : 'mc',
              question,
              options,
              correctIndices,
              hint,
              solution,
              points
            };
          })
          .filter(Boolean);
        return { title, questions };
      },

      parsePracticeApiResponse: (raw) => {
        const clean = String(raw || '')
          .replace(/```json/gi, '```')
          .replace(/```/g, '')
          .trim();
        const direct = parseJSON(clean, null);
        if (direct && typeof direct === 'object') return app.logic.normalizePracticeSet(direct);
        const objMatch = clean.match(/\{[\s\S]*\}/);
        if (objMatch) {
          const fromMatch = parseJSON(objMatch[0], null);
          if (fromMatch && typeof fromMatch === 'object') return app.logic.normalizePracticeSet(fromMatch);
        }
        return null;
      },

      buildPracticeFromCards: (cards, opts) => {
        const template = opts?.template || {};
        const wanted = Math.max(3, Math.min(12, Number(opts?.count || template.default_count || 6)));
        const sourceCards = Array.isArray(cards) ? cards.filter((c) => c.question && c.answer) : [];
        const picked = sourceCards.slice(0, wanted);
        const questions = [];

        const buildDistractors = (correct, pool) => {
          const out = [];
          const seen = new Set([String(correct || '').toLowerCase()]);
          for (const entry of pool) {
            const candidate = String(entry || '').trim();
            if (!candidate) continue;
            const key = candidate.toLowerCase();
            if (seen.has(key)) continue;
            seen.add(key);
            out.push(candidate);
            if (out.length >= 3) break;
          }
          if (out.length < 3) {
            const fallback = [
              'Die Aussage gilt ohne weitere Voraussetzungen immer.',
              'Die Aussage ist nur bei freiwilliger Anwendung relevant.',
              'Die Aussage bezieht sich ausschliesslich auf Theorie ohne Praxisbezug.'
            ];
            for (const f of fallback) {
              const key = f.toLowerCase();
              if (seen.has(key)) continue;
              out.push(f);
              if (out.length >= 3) break;
            }
          }
          return out;
        };

        picked.forEach((card, idx) => {
          const questionText = String(card.question || '').replace(/\?+$/, '').trim();
          const answerText = String(card.answer || '').trim();
          const pool = sourceCards
            .map((c) => c.answer)
            .filter((a) => String(a || '').trim() && String(a || '').trim() !== answerText);
          const distractors = buildDistractors(answerText, pool);
          const options = [answerText, ...distractors].slice(0, 4);
          options.sort((a, b) => (a > b ? 1 : -1));
          const correctIndex = options.findIndex((o) => o === answerText);

          const isOpen = Boolean(template.supports_open) && idx % 3 === 2;
          if (isOpen) {
            questions.push({
              id: `open_${idx + 1}`,
              type: 'open',
              question: `${questionText || 'Erläutere den Zusammenhang'}. Begründe deine Antwort mit Bezug auf den markierten Inhalt.`,
              options: [],
              correctIndices: [],
              hint: `Nutze die Kernaussage aus: ${answerText.slice(0, 120)}${answerText.length > 120 ? '...' : ''}`,
              solution: answerText,
              points: 3
            });
            return;
          }

          questions.push({
            id: `mc_${idx + 1}`,
            type: 'mc',
            question: `${questionText || 'Welche Aussage ist fachlich korrekt'}?`,
            options,
            correctIndices: correctIndex >= 0 ? [correctIndex] : [0],
            hint: `Pruefe den Abschnitt mit Fokus auf den Kernbegriff: ${questionText.split(' ').slice(0, 4).join(' ')}.`,
            solution: answerText,
            points: 2
          });
        });

        return {
          title: `${app.logic.getLearningTemplates()?.practice?.title_prefix || 'Uebungsaufgaben'} ${app.utils.nowStamp()}`,
          templateId: template.id || 'multiple_choice',
          templateLabel: template.label || 'Multiple Choice',
          difficulty: String(opts?.difficulty || 'mittel'),
          sourceType: 'selection-practice-local',
          questions
        };
      },

      requestSelectionPractice: async (selectedText, options = {}) => {
        const safeText = app.logic.sanitizeCardsInputText(selectedText, 1800);
        const templates = app.logic.getPracticeTemplates();
        const templateId = String(options.templateId || templates[0]?.id || 'multiple_choice');
        const template = templates.find((t) => t.id === templateId) || templates[0] || DEFAULT_LEARNING_TEMPLATES.practice.templates[0];
        const count = Math.max(3, Math.min(12, Number(options.count || template.default_count || 6)));
        const difficulty = String(options.difficulty || 'mittel');

        const localFromCards = () => {
          const cards = app.logic.buildFlashcardsFromText(safeText).slice(0, Math.max(6, count + 2));
          return app.logic.buildPracticeFromCards(cards, { template, count, difficulty });
        };

        try {
          const tplCfg = app.logic.getLearningTemplates();
          const instruction = app.logic.fillTemplateVars(
            String(tplCfg?.practice?.instruction_template || DEFAULT_LEARNING_TEMPLATES.practice.instruction_template),
            {
              template_label: template.label,
              difficulty,
              content: safeText
            }
          );

          const res = await fetch(FLASHCARDS_API_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              mode: 'exercise',
              template_id: template.id,
              template_label: template.label,
              count,
              difficulty,
              title: `${template.label} - ${app.state.settings.domain || 'Standard'}`,
              source: `Markierter Text (${app.state.settings.domain || 'Standard'})`,
              context: safeText,
              instruction,
              economyMode: true
            })
          });

          if (!res.ok) return localFromCards();

          const raw = await res.text();
          const parsedPractice = app.logic.parsePracticeApiResponse(raw);
          if (parsedPractice && parsedPractice.questions.length) {
            return {
              ...parsedPractice,
              templateId: template.id,
              templateLabel: template.label,
              difficulty,
              sourceType: 'selection-practice-api'
            };
          }

          const parsedCards = parseCardsWebhookResponse(raw);
          if (parsedCards && Array.isArray(parsedCards.cards) && parsedCards.cards.length) {
            return app.logic.buildPracticeFromCards(parsedCards.cards, { template, count, difficulty });
          }

          return localFromCards();
        } catch (_) {
          return localFromCards();
        }
      },

      isSpeechSupported: () => {
        return typeof window !== 'undefined' &&
          'speechSynthesis' in window &&
          typeof window.SpeechSynthesisUtterance !== 'undefined';
      },

      mapSpeechLang: (lang) => {
        const key = String(lang || '').trim().toUpperCase();
        const map = {
          DE: 'de-DE',
          EN: 'en-US',
          ES: 'es-ES',
          FR: 'fr-FR',
          TR: 'tr-TR',
          IT: 'it-IT',
          PL: 'pl-PL',
          NL: 'nl-NL',
          PT: 'pt-PT'
        };
        if (map[key]) return map[key];
        if (/^[a-z]{2}-[a-z]{2}$/i.test(lang || '')) return String(lang);
        if (/^[a-z]{2}$/i.test(lang || '')) return `${String(lang).toLowerCase()}-${String(lang).toUpperCase()}`;
        return String(navigator.language || 'de-DE');
      },

      stopSpeech: () => {
        if (activeTtsAudio) {
          try {
            activeTtsAudio.pause();
            activeTtsAudio.src = '';
          } catch (_) {}
          activeTtsAudio = null;
        }
        if (activeTtsAudioUrl) {
          try { URL.revokeObjectURL(activeTtsAudioUrl); } catch (_) {}
          activeTtsAudioUrl = '';
        }
        if (app.logic.isSpeechSupported()) {
          try { window.speechSynthesis.cancel(); } catch (_) {}
        }
      },

      isApiSpeechPlaying: () => {
        return Boolean(activeTtsAudio && !activeTtsAudio.paused);
      },

      requestTtsAudio: async (text, langHint, opts = {}) => {
        const payload = {
          text: String(text || '').trim().slice(0, 1800),
          lang: app.logic.mapSpeechLang(langHint || navigator.language || 'de-DE'),
          voice: String(opts.voice || 'alloy'),
          speed: Number.isFinite(Number(opts.speed)) ? Number(opts.speed) : 1
        };
        if (!payload.text) throw new Error('Kein Text zum Vorlesen vorhanden.');

        const res = await fetch(TTS_API_ENDPOINT, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (!res.ok) {
          let detail = '';
          try {
            const err = await res.json();
            detail = String(err?.error || err?.detail || '').trim();
          } catch (_) {}
          throw new Error(`TTS-API Fehler (${res.status})${detail ? `: ${detail}` : ''}`);
        }
        return res.blob();
      },

      playAudioBlob: async (blob) => {
        if (!blob || !blob.size) throw new Error('Leere Audio-Antwort.');
        app.logic.stopSpeech();
        const url = URL.createObjectURL(blob);
        const audio = new Audio(url);
        activeTtsAudio = audio;
        activeTtsAudioUrl = url;

        await new Promise((resolve, reject) => {
          audio.onended = () => resolve();
          audio.onerror = () => reject(new Error('Audio konnte nicht abgespielt werden.'));
          const p = audio.play();
          if (p && typeof p.then === 'function') {
            p.catch(() => reject(new Error('Autoplay blockiert. Bitte erneut klicken.')));
          }
        });
      },

      speakTextLocal: async (text, langHint) => {
        if (!app.logic.isSpeechSupported()) throw new Error('Sprachausgabe wird in diesem Browser nicht unterstützt.');
        const content = String(text || '').trim();
        if (!content) throw new Error('Kein Text zum Vorlesen vorhanden.');

        const synth = window.speechSynthesis;
        const utter = new SpeechSynthesisUtterance(content);
        const wantedLang = app.logic.mapSpeechLang(langHint || navigator.language || 'de-DE');
        utter.lang = wantedLang;

        const pickVoice = () => {
          const voices = synth.getVoices();
          if (!Array.isArray(voices) || !voices.length) return;
          const exact = voices.find((v) => String(v.lang || '').toLowerCase() === wantedLang.toLowerCase());
          const prefix = voices.find((v) => String(v.lang || '').toLowerCase().startsWith(wantedLang.slice(0, 2).toLowerCase()));
          utter.voice = exact || prefix || null;
        };

        pickVoice();
        if (!utter.voice && typeof synth.onvoiceschanged !== 'undefined') {
          synth.onvoiceschanged = () => pickVoice();
        }

        synth.cancel();
        await new Promise((resolve, reject) => {
          utter.onend = () => resolve();
          utter.onerror = () => reject(new Error('Lokale Sprachausgabe konnte nicht gestartet werden.'));
          synth.speak(utter);
        });
      },

      speakText: async (text, langHint, opts = {}) => {
        const preferApi = opts.preferApi !== false;
        if (preferApi) {
          try {
            const blob = await app.logic.requestTtsAudio(text, langHint, opts);
            await app.logic.playAudioBlob(blob);
            return;
          } catch (_) {
            // fallback to local speech
          }
        }
        await app.logic.speakTextLocal(text, langHint);
      },

      requestSelectionTranslation: async (text, targetLang) => {
        const res = await fetch(TRANSLATE_API_ENDPOINT, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            text: String(text || '').slice(0, 250),
            target_lang: String(targetLang || 'EN').toUpperCase()
          })
        });
        if (!res.ok) {
          let detail = '';
          try {
            const err = await res.json();
            detail = err?.error ? `: ${err.error}` : '';
          } catch (_) {}
          throw new Error(`HTTP ${res.status}${detail}`);
        }
        const parsed = await res.json();
        return String(parsed?.result || parsed?.text || parsed?.translation || '').trim();
      },

      requestSelectionRewrite: async (text, mode) => {
        const modeToStyle = {
          easy: 'neutral',
          detailed: 'besser',
          crisp: 'kurz'
        };
        const style = modeToStyle[String(mode || 'easy')] || 'neutral';
        const res = await fetch(REWRITE_API_ENDPOINT, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            text: String(text || '').slice(0, 500),
            style
          })
        });
        if (!res.ok) {
          let detail = '';
          try {
            const err = await res.json();
            detail = err?.error ? `: ${err.error}` : '';
          } catch (_) {}
          throw new Error(`HTTP ${res.status}${detail}`);
        }
        const parsed = await res.json();
        if (String(parsed?.type || '') === 'clarification') {
          const qs = Array.isArray(parsed?.questions) ? parsed.questions : [];
          const hint = String(parsed?.hint || '').trim();
          return [
            hint || 'Bitte beantworte kurz folgende Rückfragen:',
            '',
            ...qs.map((q, i) => `${i + 1}. ${q}`)
          ].join('\n').trim();
        }
        return String(parsed?.result || parsed?.text || '').trim();
      },

      sanitizeSourceList: (items) => {
        return (Array.isArray(items) ? items : [])
          .map((item) => {
            if (typeof item === 'string') return { title: item, url: '' };
            if (!item || typeof item !== 'object') return null;
            const title = String(item.title || item.name || item.label || item.url || '').trim();
            const url = String(item.url || item.link || '').trim();
            if (!title && !url) return null;
            return { title: title || url, url };
          })
          .filter(Boolean)
          .slice(0, 10);
      },

      extractSourcesFromRenderedMarkdown: (md) => {
        if (!md) return [];
        const found = [];
        const pushUrl = (urlText) => {
          const url = String(urlText || '').trim();
          if (!/^https?:\/\//i.test(url)) return;
          found.push({ title: url, url });
        };

        md.querySelectorAll('a[href]').forEach((a) => {
          const href = String(a.getAttribute('href') || '').trim();
          if (!/^https?:\/\//i.test(href)) return;
          found.push({ title: (a.textContent || href).trim(), url: href });
        });

        const nodes = md.querySelectorAll('h1,h2,h3,h4,h5,p,strong');
        let sourceAnchor = null;
        nodes.forEach((n) => {
          if (sourceAnchor) return;
          if (/^quellen?\s*:?\s*$/i.test((n.textContent || '').trim())) sourceAnchor = n;
        });

        if (sourceAnchor) {
          let cur = sourceAnchor.nextElementSibling;
          let hops = 0;
          while (cur && hops < 5) {
            if (cur.tagName === 'UL' || cur.tagName === 'OL') {
              cur.querySelectorAll('a[href]').forEach((a) => {
                const href = String(a.getAttribute('href') || '').trim();
                if (/^https?:\/\//i.test(href)) found.push({ title: (a.textContent || href).trim(), url: href });
              });
              cur.querySelectorAll('li').forEach((li) => {
                const text = (li.textContent || '').trim();
                const m = text.match(/https?:\/\/\S+/gi) || [];
                m.forEach(pushUrl);
              });
              break;
            }
            const text = (cur.textContent || '').trim();
            const urls = text.match(/https?:\/\/\S+/gi) || [];
            urls.forEach(pushUrl);
            if (urls.length) break;
            cur = cur.nextElementSibling;
            hops += 1;
          }
        }

        const unique = [];
        const seen = new Set();
        found.forEach((s) => {
          const key = `${s.title}|${s.url}`.toLowerCase();
          if (seen.has(key)) return;
          seen.add(key);
          unique.push(s);
        });
        return unique.slice(0, 10);
      },

      decorateBubble: (md, sources) => {
        md.querySelectorAll('table').forEach((table) => {
          const wrap = document.createElement('div');
          wrap.className = 'table-wrap';
          table.parentNode.insertBefore(wrap, table);
          wrap.appendChild(table);
        });

        const sourceList = app.logic.sanitizeSourceList(sources);
        const fallbackSources = sourceList.length ? [] : app.logic.extractSourcesFromRenderedMarkdown(md);
        const finalSources = sourceList.length ? sourceList.slice() : fallbackSources.slice();
        const plainText = String(md.innerText || '').toLowerCase();
        const mentionsBBIG = /(?:\bbbig\b|berufsbildungsgesetz)/i.test(plainText);
        if (mentionsBBIG) {
          const hasDoc = finalSources.some((s) => String(s.url || '').includes('BBIG_V20022026.pdf'));
          if (!hasDoc) {
            finalSources.push({
              title: 'Berufsbildungsgesetz (BBiG) - Volltext (PDF)',
              url: BBIG_PDF_PATH
            });
          }
        }

        if (finalSources.length) {
          const panel = document.createElement('section');
          panel.className = 'source-panel';
          const title = document.createElement('h4');
          title.className = 'source-head';
          title.textContent = 'Quellen';
          const ul = document.createElement('ul');
          ul.className = 'source-list';
          finalSources.forEach((s) => {
            const li = document.createElement('li');
            if (s.url) {
              li.innerHTML = `<a href="${encodeURI(s.url)}">${app.utils.safeText(s.title)}</a>`;
            } else {
              li.textContent = s.title;
            }
            ul.appendChild(li);
          });
          panel.appendChild(title);
          panel.appendChild(ul);
          md.appendChild(panel);
        }

        const keywordLinks = app.logic.findKeywordLinks(md.innerText || '');
        if (!keywordLinks.length) {
          return;
        }

        const keywordPanel = document.createElement('section');
        keywordPanel.className = 'keyword-panel';
        const keywordTitle = document.createElement('h4');
        keywordTitle.className = 'keyword-head';
        keywordTitle.textContent = 'Lernverzeichnis';
        const keywordList = document.createElement('ul');
        keywordList.className = 'keyword-list';
        keywordLinks.forEach((entry) => {
          const li = document.createElement('li');
          const noteText = entry.note ? ` - ${app.utils.safeText(entry.note)}` : '';
          li.innerHTML = `<a href="${encodeURI(entry.url)}">${app.utils.safeText(entry.title)}</a>${noteText}`;
          keywordList.appendChild(li);
        });
        keywordPanel.appendChild(keywordTitle);
        keywordPanel.appendChild(keywordList);
        md.appendChild(keywordPanel);
        app.utils.sanitizeLinks(md);
      },

      sendMessage: async () => {
        if (!app.state.consentGiven) {
          app.ui.openModal('modal-disclaimer');
          return;
        }

        if (app.state.isSending) {
          if (app.state.requestController) app.state.requestController.abort();
          return;
        }

        const text = app.ui.input.value.trim();
        if (!text) return;

        if (app.state.settings.fastMode?.enabled && app.logic.needsSlowModeHint(text)) {
          const disableFast = confirm(
            'Hinweis: Für diese Anfrage wird empfohlen, den Schnellmodus auszuschalten, um bessere Nachvollziehbarkeit/Quellen zu erhalten.\n\n' +
            'Jetzt Schnellmodus AUS schalten?'
          );
          if (disableFast) {
            app.state.settings.fastMode.enabled = false;
            app.ui.syncFastModeControls();
            app.ui.updateDomainUI();
            app.utils.save();
          }
          alert('Die Anfrage wird jetzt gesendet. Prüfe die Antwort bitte besonders sorgfältig.');
        }

        app.ui.input.value = '';
        app.ui.input.dispatchEvent(new Event('input'));

        let s = app.logic.activeSession();
        if (!s) {
          app.logic.newChat();
          s = app.logic.activeSession();
          if (!s) return;
        }

        app.state.lastQuestion = text;
        app.logic.rememberQuestion(text);

        const displayText = app.state.settings.name
          ? `${app.state.settings.name}: ${text}`
          : text;

        s.messages.push({ role: 'user', content: displayText, sources: [] });
        if (!s.name || s.name === 'Neuer Chat') s.name = text.slice(0, 48);

        app.ui.log.appendChild(app.ui.createBubble('user', displayText));
        const loading = app.ui.loadingRow();
        app.ui.log.appendChild(loading);
        app.ui.scrollBottom();

        app.ui.setSendingState(true);
        app.utils.save();

        const controller = new AbortController();
        app.state.requestController = controller;
        const timeout = setTimeout(() => controller.abort(), 40000);

        try {
          const mobileReaderActive = app.logic.isMobileReaderEnabled();
          const effectiveFastMode = mobileReaderActive
            ? false
            : Boolean(app.state.settings.fastMode && app.state.settings.fastMode.enabled);
          const effectiveSources = mobileReaderActive
            ? { ...app.state.settings.sources, ...MAKEFLOW_ONLY_SOURCES }
            : app.state.settings.sources;

          const payload = {
            question: app.utils.truncate(text, 1300),
            fachmodus: app.state.settings.domain || '',
            schnellmodus: effectiveFastMode,
            history: app.utils.chatContext(s),
            sources: effectiveSources,
            routing: {
              preferred_model: effectiveFastMode ? 'Linda3Schnellmodus' : 'default'
            },
            ilias: {
              enabled: mobileReaderActive
                ? false
                : Boolean(app.state.settings.ilias.enabled && effectiveSources.ilias),
              mode: 'manual-links',
              courseId: app.state.settings.ilias.courseId || '',
              keywords: []
            },
            clientMeta: {
              app: 'LINDA3',
              version: APP_VERSION,
              ts: new Date().toISOString()
            }
          };

          const compareEnabled = mobileReaderActive
            ? false
            : Boolean(app.state.settings.compareMode && app.state.settings.compareMode.enabled);
          if (compareEnabled) {
            let makeParsed = { answer: '', sources: [] };
            let deepParsed = { answer: '', sources: [] };

            try {
              makeParsed = await app.logic.requestAnswer(API_ENDPOINT, payload, controller.signal);
            } catch (e) {
              makeParsed = { answer: `❌ Linda 3.0 Fehler: ${e?.message || 'unbekannt'}`, sources: [] };
            }

            await new Promise((resolve) => setTimeout(resolve, 1000));

            const deepseekPayload = {
              ...payload,
              routing: {
                ...(payload.routing || {}),
                preferred_model: 'deepseek'
              },
              clientMeta: {
                ...(payload.clientMeta || {}),
                channel: 'deepseek'
              }
            };

            try {
              deepParsed = await app.logic.requestAnswer(
                DEEPSEEK_API_ENDPOINT,
                deepseekPayload,
                controller.signal
              );
            } catch (e) {
              const msg = String(e?.message || '');
              const missingDeepseekRoute = msg.includes('HTTP 404') && DEEPSEEK_API_ENDPOINT !== API_ENDPOINT;
              if (missingDeepseekRoute) {
                try {
                  deepParsed = await app.logic.requestAnswer(
                    API_ENDPOINT,
                    deepseekPayload,
                    controller.signal
                  );
                } catch (fallbackErr) {
                  deepParsed = { answer: `❌ Schnellmodus Fehler: ${fallbackErr?.message || 'unbekannt'}`, sources: [] };
                }
              } else {
                deepParsed = { answer: `❌ Schnellmodus Fehler: ${e?.message || 'unbekannt'}`, sources: [] };
              }
            }

            s.messages.push({
              role: 'assistant',
              content: `Linda 3.0:\n${makeParsed.answer}\n\nSchnellmodus:\n${deepParsed.answer}`,
              sources: [],
              compare: {
                make: makeParsed,
                deepseek: deepParsed
              }
            });
            app.ui.log.appendChild(app.ui.createCompareBubble(makeParsed, deepParsed));
          } else {
            const parsed = await app.logic.requestAnswer(API_ENDPOINT, payload, controller.signal);
            s.messages.push({ role: 'assistant', content: parsed.answer, sources: parsed.sources });
            app.ui.log.appendChild(app.ui.createBubble('assistant', parsed.answer, parsed.sources));
          }
          loading.remove();
          if (!app.state.telemetry.firstSelectionHintShown) {
            app.ui.log.appendChild(
              app.ui.createBubble(
                'assistant',
                'Tipp: Du kannst Text in meiner Antwort markieren und per Rechtsklick direkt Lernkarten über den Webhook erstellen.'
              )
            );
            app.state.telemetry.firstSelectionHintShown = true;
          }
          app.utils.save();
          app.ui.scrollBottom();
        } catch (err) {
          loading.remove();
          const offline = !navigator.onLine;
          const timeoutErr = err?.name === 'AbortError';
          const msg = offline
            ? 'Du bist offline. Bitte Internetverbindung prüfen.'
            : timeoutErr
              ? 'Anfrage abgebrochen oder Timeout erreicht.'
              : `Verbindungsfehler: ${err?.message || 'unbekannt'}`;

          app.ui.log.appendChild(app.ui.createBubble('assistant', `❌ ${msg}`));
          app.ui.scrollBottom();
        } finally {
          clearTimeout(timeout);
          app.state.requestController = null;
          app.ui.setSendingState(false);
          app.ui.input.focus();
          document.getElementById('snippet-popup').classList.remove('active');
        }
      },

      getBubbleText: (btn) => {
        const row = btn.closest('.msg-row');
        const items = Array.from(app.ui.log.children);
        const idx = items.indexOf(row);
        let q = '';

        for (let i = idx - 1; i >= 0; i -= 1) {
          if (items[i].classList.contains('user')) {
            q = items[i].querySelector('.md')?.innerText || '';
            break;
          }
        }

        const a = row.querySelector('.md')?.innerText || '';
        return { q, a };
      },

      copyBubble: (btn) => {
        const { q, a } = app.logic.getBubbleText(btn);
        navigator.clipboard.writeText(`Frage: ${q}\n\nAntwort: ${a}`).then(() => {
          const old = btn.textContent;
          btn.textContent = 'Kopiert';
          setTimeout(() => { btn.textContent = old; }, 1100);
        }).catch(() => {
          alert('Kopieren nicht möglich.');
        });
      },

      shareBubble: (btn) => {
        const { q, a } = app.logic.getBubbleText(btn);
        const text = `Frage: ${q}\n\nAntwort: ${a}`;
        if (navigator.share) {
          navigator.share({ title: 'LINDA3', text }).catch(() => {});
          return;
        }
        window.location.href = `mailto:?subject=LINDA3&body=${encodeURIComponent(text)}`;
      },

      pdfBubble: (btn) => {
        const bubble = btn.closest('.msg-wrap')?.querySelector('.bubble.assistant');
        if (!bubble) return;
        const win = window.open('', '_blank');
        if (!win) {
          alert('Popup blockiert. Erlaube Popups für PDF-Export.');
          return;
        }

        win.document.write(`
          <html>
            <head>
              <title>LINDA3 Export</title>
              <style>
                body { font-family: 'Manrope', Arial, sans-serif; margin: 22px; color: #132236; }
                h1 { color: #0d4d98; margin: 0 0 12px; }
                .box { border: 1px solid #d8e3f3; border-radius: 12px; padding: 14px; }
              </style>
            </head>
            <body>
              <h1>LINDA3 Antwort</h1>
              <p style="margin-top:0;color:#61738c;">Exportiert am ${app.utils.nowStamp()}</p>
              <div class="box">${bubble.innerHTML}</div>
            </body>
          </html>
        `);

        win.document.close();
        setTimeout(() => {
          win.focus();
          win.print();
        }, 260);
      },

      buildFlashcardsFromText: (text) => {
        const clean = String(text || '')
          .replace(/\r/g, '')
          .replace(/`{1,3}[^`]*`{1,3}/g, '')
          .replace(/\*\*|__/g, '')
          .replace(/\[(.*?)\]\((.*?)\)/g, '$1')
          .replace(/^Frage:\s*/gim, '')
          .replace(/^Anfrage:\s*/gim, '')
          .trim();

        const lines = clean
          .split('\n')
          .map((l) => l.trim())
          .filter(Boolean)
          .filter((l) => !/^quellen?\s*:?\s*$/i.test(l))
          .filter((l) => !/^hinweis\s*:/i.test(l))
          .filter((l) => !/^nutze die schalter/i.test(l))
          .filter((l) => !/^öffne lernkarten/i.test(l))
          .filter((l) => !/^ilias kann/i.test(l));

        const bullets = lines
          .filter((l) => /^[-*]|^\d+\./.test(l))
          .map((l) => l.replace(/^[-*]\s*/, '').replace(/^\d+\.\s*/, '').trim())
          .filter((l) => l.length > 10);

        const sentences = clean
          .split(/(?<=[.!?])\s+/)
          .map((s) => s.trim())
          .filter((s) => s.length > 24)
          .filter((s) => !/^quellen?\s*:?\s*$/i.test(s));

        const compact = (v) => String(v || '').replace(/\s+/g, ' ').trim();
        const clauses = [...bullets, ...sentences]
          .flatMap((s) => compact(s).split(/\s*[;•]\s+/))
          .map(compact)
          .filter((s) => s.length >= 18);

        const seeds = clauses.slice(0, 36);
        const cards = [];
        const used = new Set();

        const addCard = (question, answer) => {
          const q = String(question || '').trim();
          const a = String(answer || '').trim();
          if (!q || !a) return;
          if (q.length < 8 || a.length < 8) return;
          const key = `${q.toLowerCase()}|${a.toLowerCase()}`;
          if (used.has(key)) return;
          used.add(key);
          cards.push({ question: q, answer: a });
        };

        const extractTopic = (txt) => {
          const t = compact(txt);
          const withParenRemoved = t.replace(/\([^)]{1,80}\)/g, '').trim();

          const m1 = withParenRemoved.match(/^(.{4,90}?)\s+(muss|müssen|darf|dürfen|kann|können|soll|sollen|ist|sind|gilt|gelten|beträgt|betragen)\b/i);
          if (m1) return compact(m1[1]).replace(/[,:;.-]+$/, '');

          const m2 = withParenRemoved.match(/^bei\s+(.{4,90}?)(?:\s+gilt|\s+ist|\s+muss|\s+soll|,)/i);
          if (m2) return `bei ${compact(m2[1])}`;

          const m3 = withParenRemoved.match(/für\s+(.{4,80}?)(?:\s+gilt|\s+ist|\s+sind|\s+muss|\s+soll|,|\.|$)/i);
          if (m3) return `für ${compact(m3[1])}`;

          return compact(withParenRemoved.split(/\s+/).slice(0, 9).join(' '));
        };

        const toQuestionFromFact = (part) => {
          const txt = compact(part);
          const topic = extractTopic(txt);

          if (/\b§\s*\d+[a-z]?\b/i.test(txt)) {
            return {
              question: `Welche Regelung beschreibt ${topic}?`,
              answer: txt
            };
          }

          const colon = txt.match(/^([^:]{3,80}):\s+(.{8,})$/);
          if (colon) {
            return {
              question: `Wie wird ${colon[1].trim()} im Text konkret beschrieben?`,
              answer: colon[2].trim()
            };
          }

          const isDef = txt.match(/^(.{3,80}?)\s+(ist|sind)\s+(.{10,})$/i);
          if (isDef) {
            return {
              question: `Was ist ${isDef[1].trim()}?`,
              answer: `${isDef[1].trim()} ${isDef[2]} ${isDef[3].trim()}`
            };
          }

          const condition = txt.match(/^(Bei|Wenn|Falls|Sobald)\s+(.{6,140})$/i);
          if (condition) {
            return {
              question: `Was gilt, ${condition[1].toLowerCase()} ${condition[2].replace(/[.;]+$/, '')}?`,
              answer: txt
            };
          }

          const hasRuleVerb = /\b(muss|müssen|darf|dürfen|kann|können|soll|sollen|ist verpflichtet|gilt|gelten)\b/i.test(txt);
          if (hasRuleVerb) {
            return {
              question: `Welche Regel gilt ${topic.startsWith('für') ? topic : `für ${topic}`}?`,
              answer: txt
            };
          }

          const hasNumber = /\b\d+\s*(?:%|UE|Stunden?|Tage|Wochen?|Monate|Jahre|Uhr)\b/i.test(txt);
          if (hasNumber) {
            return {
              question: `Welche konkrete Vorgabe nennt der Text ${topic.startsWith('für') ? topic : `für ${topic}`}?`,
              answer: txt
            };
          }

          const hasBecause = txt.match(/^(.{8,120}?)\s+(weil|da)\s+(.{8,})$/i);
          if (hasBecause) {
            return {
              question: `Warum ${hasBecause[1].trim()}?`,
              answer: `${hasBecause[2]} ${hasBecause[3].trim()}`
            };
          }

          const startsWithVerb = txt.match(/^(Nutze|Verwende|Beachte|Prüfe|Aktiviere|Deaktiviere|Wähle|Öffne|Plane|Dokumentiere)\s+(.{6,})$/i);
          if (startsWithVerb) {
            return {
              question: `Welche konkrete Handlung wird empfohlen?`,
              answer: `${startsWithVerb[1]} ${startsWithVerb[2].trim()}`
            };
          }

          return {
            question: `Welche Kernaussage enthält der Text zu ${topic}?`,
            answer: txt
          };
        };

        seeds.forEach((seed) => {
          const qa = toQuestionFromFact(seed);
          addCard(qa.question, qa.answer);
        });

        if (!cards.length) {
          return [{
            question: 'Keine Lernfragen erkannt',
            answer: 'Bitte zuerst eine fachliche Antwort erzeugen und dann Lernkarten öffnen.'
          }];
        }

        return cards.slice(0, 18);
      },

      openFlashcardsTab: (forcedText) => {
        const text = forcedText || (() => {
          const s = app.logic.activeSession();
          if (!s) return '';
          const msg = [...s.messages].reverse().find((m) => m.role === 'assistant' && !/^❌/.test(m.content));
          return msg ? msg.content : '';
        })();

        const baseCards = app.logic.buildFlashcardsFromText(text);
        const stats = parseJSON(localStorage.getItem(CARDS_STATS_KEY) || '{}', {});
        const cardId = (c) => btoa(unescape(encodeURIComponent(`${c.question}|${c.answer}`))).slice(0, 24);
        const cards = baseCards
          .map((c) => {
            const id = cardId(c);
            const st = stats[id] || {};
            return {
              ...c,
              id,
              adaptive: {
                ease: Number(st.ease || 2),
                reps: Number(st.reps || 0),
                dueAt: Number(st.dueAt || 0)
              }
            };
          })
          .sort((a, b) => a.adaptive.dueAt - b.adaptive.dueAt);

        const payload = {
          cards,
          generatedAt: app.utils.nowStamp(),
          sourceLength: String(text || '').length,
          adaptive: true
        };

        localStorage.setItem(CARDS_KEY, JSON.stringify(payload));
        const target = `${window.location.pathname}?view=cards`;
        const tab = window.open(target, '_blank', 'noopener');
        if (!tab) alert('Popup blockiert. Bitte Popups erlauben, um Karten in neuem Tab zu öffnen.');
      },

      clearAll: () => {
        if (!confirm('Alle Verläufe wirklich löschen?')) return;
        app.state.sessions = [];
        app.state.activeId = null;
        app.ui.log.innerHTML = '';
        app.utils.save();
        app.logic.newChat();
      },

      openFeedback: () => {
        const s = app.logic.activeSession();
        let body = 'Mein Feedback zu LINDA3:%0D%0A%0D%0A';
        if (s) {
          (s.messages || []).forEach((m) => {
            body += `${m.role === 'user' ? 'Ich' : 'LINDA3'}: ${encodeURIComponent(m.content)}%0D%0A`;
          });
        }
        window.location.href = `mailto:KI-TEST@GMX.COM?subject=Feedback LINDA3&body=${body}`;
      }
    }
  };

  window.app = app;

  const initCardTab = () => {
    const root = document.body;
    const payload = parseJSON(localStorage.getItem(CARDS_KEY) || '{}', {});
    const cards = Array.isArray(payload.cards) ? payload.cards : [];
    const stats = parseJSON(localStorage.getItem(CARDS_STATS_KEY) || '{}', {});
    const now = Date.now();

    root.innerHTML = `
      <div class="cards-layout">
        <div class="cards-top">
          <div>
            <h1 class="cards-title">LINDA3 Lernkarten</h1>
            <p class="cards-sub">Generiert: ${app.utils.safeText(payload.generatedAt || 'unbekannt')} • Karten: ${cards.length} • Adaptiv: ${payload.adaptive ? 'an' : 'aus'}</p>
          </div>
          <button class="btn-icon" onclick="window.close()">Schließen</button>
        </div>
        <main class="cards-body" id="cards-body"></main>
      </div>
    `;

    const body = document.getElementById('cards-body');
      if (!cards.length) {
      body.innerHTML = '<div class="state-msg">Keine Lernkarten vorhanden. Markiere im Haupttab eine Textpassage und nutze den Rechtsklick für Lernkarten.</div>';
      return;
    }

    body.innerHTML = cards.map((card, idx) => `
      <article class="flash" data-card="${idx}">
        <div role="button" tabindex="0" aria-label="Karte ${idx + 1} umdrehen" class="flash-toggle">
          <div class="flash-inner">
            <div class="flash-face front">
              <p class="flash-kicker">Frage</p>
              <h4>${app.utils.safeText(card.question)}</h4>
              <p>Tippen zum Umdrehen</p>
            </div>
            <div class="flash-face back">
              <p class="flash-kicker">Antwort</p>
              <p>${app.utils.safeText(card.answer)}</p>
              <p style="margin-top:8px; font-size:0.78rem; color:#31567f;">
                Status: ${((stats[card.id]?.dueAt || card.adaptive?.dueAt || 0) <= now) ? 'fällig' : 'geplant'} • Wiederholungen: ${Number(stats[card.id]?.reps || card.adaptive?.reps || 0)}
              </p>
            </div>
          </div>
        </div>
        <div style="display:flex; gap:6px; margin-top:8px; flex-wrap:wrap;">
          <button type="button" class="btn-icon" style="height:34px; min-width:90px;" data-rate="hard" data-card-id="${card.id}">Schwer</button>
          <button type="button" class="btn-icon" style="height:34px; min-width:90px;" data-rate="mid" data-card-id="${card.id}">Mittel</button>
          <button type="button" class="btn-icon btn-primary" style="height:34px; min-width:90px;" data-rate="easy" data-card-id="${card.id}">Leicht</button>
        </div>
      </article>
    `).join('');

    body.addEventListener('click', (e) => {
      const rateBtn = e.target.closest('[data-rate][data-card-id]');
      if (rateBtn) {
        e.preventDefault();
        e.stopPropagation();
        const id = rateBtn.getAttribute('data-card-id');
        const rate = rateBtn.getAttribute('data-rate');
        const prev = stats[id] || { ease: 2, reps: 0, dueAt: 0 };
        const nextEase = Math.max(1.3, Math.min(2.8, prev.ease + (rate === 'easy' ? 0.2 : rate === 'hard' ? -0.2 : 0)));
        const baseHours = rate === 'easy' ? 72 : rate === 'mid' ? 24 : 8;
        stats[id] = {
          ease: nextEase,
          reps: Number(prev.reps || 0) + 1,
          dueAt: Date.now() + Math.round(baseHours * nextEase) * 3600000
        };
        localStorage.setItem(CARDS_STATS_KEY, JSON.stringify(stats));
        rateBtn.textContent = 'Gespeichert';
        setTimeout(() => {
          if (rate === 'easy') rateBtn.textContent = 'Leicht';
          if (rate === 'mid') rateBtn.textContent = 'Mittel';
          if (rate === 'hard') rateBtn.textContent = 'Schwer';
        }, 900);
        return;
      }
      const card = e.target.closest('.flash');
      if (!card) return;
      card.classList.toggle('flipped');
    });

    body.addEventListener('keydown', (e) => {
      const toggle = e.target.closest('.flash-toggle');
      if (!toggle) return;
      if (e.key !== 'Enter' && e.key !== ' ') return;
      e.preventDefault();
      const card = toggle.closest('.flash');
      if (!card) return;
      card.classList.toggle('flipped');
    });
  };

  const initPracticeTab = () => {
    const root = document.getElementById('app');
    const payload = parseJSON(localStorage.getItem(PRACTICE_KEY) || '{}', {});
    const questions = Array.isArray(payload.questions) ? payload.questions : [];

    root.innerHTML = `
      <div class="cards-layout">
        <div class="cards-top">
          <div>
            <h1 class="cards-title">LINDA3 Uebungsaufgaben</h1>
            <p class="cards-sub">${app.utils.safeText(payload.title || 'Uebungsaufgaben')} • ${questions.length} Aufgaben • Generiert: ${app.utils.safeText(payload.generatedAt || 'unbekannt')}</p>
          </div>
          <button class="btn-icon" onclick="window.close()">Schließen</button>
        </div>
        <main class="cards-body" id="practice-body" style="grid-template-columns:1fr;max-width:960px;"></main>
      </div>
    `;

    const body = document.getElementById('practice-body');
    if (!questions.length) {
      body.innerHTML = '<div class="state-msg">Keine Uebungsaufgaben vorhanden. Markiere im Haupttab eine Textpassage und nutze den Rechtsklick fuer Uebungsaufgaben.</div>';
      return;
    }

    body.innerHTML = questions.map((q, idx) => {
      const optionsHtml = (q.type === 'mc')
        ? `<div class="practice-options">${(Array.isArray(q.options) ? q.options : []).map((opt, i) => (
            `<label class="practice-option"><input type="checkbox" data-practice-input="${idx}" data-opt="${i}"><span>${app.utils.safeText(opt)}</span></label>`
          )).join('')}</div>`
        : `<textarea class="practice-open-answer" data-practice-open="${idx}" placeholder="Hier deine Antwort eingeben..."></textarea>`;

      return `
        <article class="practice-card" data-practice-card="${idx}">
          <div class="practice-header">
            <h3>Aufgabe ${idx + 1}</h3>
            <span class="practice-points">${Number(q.points || 2)} P</span>
          </div>
          <p class="practice-question">${app.utils.safeText(q.question || '')}</p>
          ${optionsHtml}
          <div class="practice-actions">
            <button type="button" class="btn-icon btn-primary" data-practice-hint="${idx}">Hinweis</button>
            <button type="button" class="btn-icon" data-practice-solution="${idx}">Loesung anzeigen</button>
          </div>
          <div class="practice-solution" id="practice-solution-${idx}" hidden></div>
        </article>
      `;
    }).join('');

    body.addEventListener('click', (e) => {
      const hintBtn = e.target.closest('[data-practice-hint]');
      if (hintBtn) {
        const idx = Number(hintBtn.getAttribute('data-practice-hint'));
        const q = questions[idx];
        alert(String(q?.hint || 'Kein Hinweis vorhanden.'));
        return;
      }

      const solutionBtn = e.target.closest('[data-practice-solution]');
      if (solutionBtn) {
        const idx = Number(solutionBtn.getAttribute('data-practice-solution'));
        const q = questions[idx];
        const box = document.getElementById(`practice-solution-${idx}`);
        if (!box) return;
        box.hidden = !box.hidden;
        if (!box.hidden) {
          let evaluation = '';
          if (q?.type === 'mc') {
            const selected = Array.from(body.querySelectorAll(`[data-practice-input="${idx}"]:checked`)).map((el) => Number(el.getAttribute('data-opt')));
            const expected = Array.isArray(q.correctIndices) ? q.correctIndices : [];
            const selectedKey = selected.slice().sort().join(',');
            const expectedKey = expected.slice().sort().join(',');
            evaluation = selectedKey === expectedKey ? 'Bewertung: korrekt.' : 'Bewertung: noch nicht korrekt.';
          }
          const solutionText = String(q?.solution || '').trim() || 'Keine Musterloesung hinterlegt.';
          box.textContent = `${evaluation ? `${evaluation} ` : ''}Musterloesung: ${solutionText}`;
        }
      }
    });
  };

  const initMainApp = () => {
    if (app.utils.isMobileClient()) {
      document.body.classList.add('mobile-fallback');
    }

    app.utils.load();
    app.logic.loadKeywordLinks();
    app.logic.loadLearningTemplates();
    app.ui.updateDomainUI();
    app.ui.renderSourceToolbar();
    app.ui.syncFastModeControls();
    app.ui.syncCompareModeControls();
    app.ui.syncLearningDirectoryControls();
    app.ui.syncMobileReaderControls();
    app.ui.applyMobileReaderClass();
    if (app.logic.isMobileReaderEnabled()) {
      app.logic.setMobileReader(true);
    }

    if (app.state.consentGiven) {
      document.getElementById('modal-disclaimer').classList.remove('open');
    }

    const c1 = document.getElementById('consent-data');
    const c2 = document.getElementById('consent-forward');
    const start = document.getElementById('btn-start-disclaimer');
    const syncStart = () => { start.disabled = !(c1.checked && c2.checked); };
    c1.addEventListener('change', syncStart);
    c2.addEventListener('change', syncStart);

    app.ui.input.addEventListener('input', function () {
      this.style.height = 'auto';
      this.style.height = Math.min(this.scrollHeight, 180) + 'px';

      const val = this.value;
      if (val.startsWith('/')) {
        const q = val.slice(1).toLowerCase();
        const matches = (app.state.settings.snippets || [])
          .filter((s) => s.toLowerCase().includes(q))
          .slice(0, 12)
          .map((s) => ({ label: s, value: s, kind: 'Snippet' }));
        app.ui.showSnippetPopup(matches);
      } else {
        const memorySuggestions = app.logic.findQuestionSuggestions(val, 6)
          .map((s) => ({ label: s, value: s, kind: 'Aehnliche Frage aus Verlauf' }));
        const promptSuggestions = app.logic.getPromptingSuggestions(val);
        const allSuggestions = [...memorySuggestions, ...promptSuggestions]
          .filter((item, idx, arr) => arr.findIndex((x) => x.value === item.value) === idx)
          .slice(0, 8);
        if (allSuggestions.length) app.ui.showSnippetPopup(allSuggestions);
        else document.getElementById('snippet-popup').classList.remove('active');
      }
    });

    app.ui.input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        app.logic.sendMessage();
      }
    });

    let sendThrottle = 0;
    const triggerSend = (e) => {
      if (e) {
        e.preventDefault();
        e.stopPropagation();
      }
      const now = Date.now();
      if (now - sendThrottle < 300) return;
      sendThrottle = now;
      app.logic.sendMessage();
    };

    app.ui.sendBtn.addEventListener('click', triggerSend);
    app.ui.sendBtn.addEventListener('touchend', triggerSend, { passive: false });

    const fastMainOn = document.getElementById('fastmode-main-on');
    const fastMainOff = document.getElementById('fastmode-main-off');
    const syncFastMode = () => {
      const wantsOn = Boolean(fastMainOn && fastMainOn.checked);
      if (wantsOn && !app.state.settings.fastMode.consentAccepted) {
        const accepted = confirm(
          'Du aktivierst den Schnellmodus, dieser unterstützt keine Quellenangaben der hinterlegten Dokumente. ' +
          'Prüfe sehr intensiv die Antworten, da der Schnellmodus Fehler beinhalten kann. ' +
          'Jede KI-Antwort muss überprüft werden.\n\nBestätigen?'
        );
        if (!accepted) {
          app.state.settings.fastMode.enabled = false;
          app.ui.syncFastModeControls();
          app.ui.updateDomainUI();
          app.utils.save();
          return;
        }
        app.state.settings.fastMode.consentAccepted = true;
      }

      app.state.settings.fastMode.enabled = wantsOn;
      app.utils.save();
      app.ui.updateDomainUI();
    };
    if (fastMainOn) fastMainOn.addEventListener('change', syncFastMode);
    if (fastMainOff) fastMainOff.addEventListener('change', syncFastMode);

    const compareMainOn = document.getElementById('compare-main-on');
    const compareMainOff = document.getElementById('compare-main-off');
    const syncCompareMode = () => {
      const wantsOn = Boolean(compareMainOn && compareMainOn.checked);
      app.state.settings.compareMode.enabled = wantsOn;
      app.utils.save();
      app.ui.updateDomainUI();
    };
    if (compareMainOn) compareMainOn.addEventListener('change', syncCompareMode);
    if (compareMainOff) compareMainOff.addEventListener('change', syncCompareMode);

    const directoryMainOn = document.getElementById('directory-main-on');
    const directoryMainOff = document.getElementById('directory-main-off');
    const syncLearningDirectory = () => {
      const wantsOn = Boolean(directoryMainOn && directoryMainOn.checked);
      app.state.settings.sources.directory = wantsOn;
      app.utils.save();
      app.ui.updateDomainUI();
      app.ui.renderSourceToolbar();
      app.ui.renderSourceToggleList();
    };
    if (directoryMainOn) directoryMainOn.addEventListener('change', syncLearningDirectory);
    if (directoryMainOff) directoryMainOff.addEventListener('change', syncLearningDirectory);

    const mobileReaderOn = document.getElementById('mobile-reader-on');
    const mobileReaderOff = document.getElementById('mobile-reader-off');
    const syncMobileReader = () => {
      const wantsOn = Boolean(mobileReaderOn && mobileReaderOn.checked);
      app.logic.setMobileReader(wantsOn);
    };
    if (mobileReaderOn) mobileReaderOn.addEventListener('change', syncMobileReader);
    if (mobileReaderOff) mobileReaderOff.addEventListener('change', syncMobileReader);

    document.getElementById('snippet-popup').addEventListener('click', (e) => {
      const item = e.target.closest('.snippet-item');
      if (!item) return;
      app.logic.insertSnippet(decodeURIComponent(item.dataset.snippet || ''));
    });

    document.getElementById('source-toolbar').addEventListener('change', (e) => {
      const cb = e.target.closest('[data-source-cb]');
      if (!cb) return;
      const key = cb.getAttribute('data-source-cb');
      app.state.settings.sources[key] = cb.checked;
      if (key === 'ilias') app.state.settings.ilias.enabled = cb.checked;
      app.utils.save();
      app.ui.updateDomainUI();
      app.ui.renderSourceToolbar();
      app.ui.syncLearningDirectoryControls();
    });

    document.getElementById('source-toggle-list').addEventListener('change', (e) => {
      const cb = e.target.closest('[data-source-setting]');
      if (!cb) return;
      const key = cb.getAttribute('data-source-setting');
      app.state.settings.sources[key] = cb.checked;
      if (key === 'ilias') app.state.settings.ilias.enabled = cb.checked;
      if (key === 'directory') app.ui.syncLearningDirectoryControls();
    });

    document.getElementById('snippet-list-container').addEventListener('click', (e) => {
      const btn = e.target.closest('[data-remove-snippet]');
      if (!btn) return;
      app.logic.removeSnippet(Number(btn.getAttribute('data-remove-snippet')));
    });

    document.getElementById('session-list').addEventListener('click', (e) => {
      const item = e.target.closest('[data-session-id]');
      if (!item) return;
      app.logic.switchSession(item.getAttribute('data-session-id'));
    });

    app.ui.log.addEventListener('click', (e) => {
      const modeBtn = e.target.closest('[data-set-domain]');
      if (modeBtn) {
        const mode = modeBtn.getAttribute('data-set-domain') || '';
        app.state.settings.domain = mode;
        app.utils.save();
        app.ui.updateDomainUI();
        app.ui.log.querySelectorAll('.mode-card-row').forEach((el) => el.remove());
        app.ui.log.appendChild(app.ui.createBubble('assistant', `Fachmodus wurde auf **${mode}** gesetzt.`));
        app.ui.scrollBottom();
        return;
      }

      const btn = e.target.closest('[data-action]');
      if (!btn) return;
      const action = btn.getAttribute('data-action');
      if (action === 'copy') app.logic.copyBubble(btn);
      if (action === 'share') app.logic.shareBubble(btn);
      if (action === 'pdf') app.logic.pdfBubble(btn);
      if (action === 'feedback') app.ui.openModal('modal-feedback');
    });

    app.ui.log.addEventListener('contextmenu', (e) => {
      if (!app.logic.prepareSelectionDraftFromEvent(e)) return;
      e.preventDefault();
      app.ui.showSelectionMenu(e.clientX + 6, e.clientY + 6);
    });

    app.ui.log.addEventListener('mouseup', (e) => {
      if (!app.logic.prepareSelectionDraftFromEvent(e)) return;
      if (app.utils.isMobileClient()) {
        app.ui.showSelectionMenu(e.clientX + 6, e.clientY + 6);
      }
    });

    document.getElementById('selection-cards-btn').addEventListener('click', () => {
      const draft = app.state.selectionDraft;
      if (!draft || !draft.text) return;
      app.ui.hideSelectionMenu();
      app.ui.openSelectionActionModal({
        title: 'Lernkarten aus Markierung',
        preview: draft.text.slice(0, 450),
        fieldsHtml:
          '<div class="selection-field"><label for="selection-cards-count">Anzahl Lernkarten</label><select id="selection-cards-count"><option value="6">6</option><option value="8" selected>8</option><option value="10">10</option><option value="12">12</option></select></div>',
        confirmLabel: 'Lernkarten erstellen',
        onConfirm: async () => {
          const count = Number(document.getElementById('selection-cards-count')?.value || 8);
          const result = await app.logic.requestSelectionFlashcards(draft.text, count);
          app.logic.openCardsTabWithPayload({
            cards: result.cards || [],
            generatedAt: app.utils.nowStamp(),
            sourceLength: draft.text.length,
            adaptive: true,
            deckTitle: result.deckTitle || 'Lernkarten aus Auswahl',
            sourceType: result.sourceType || 'selection-api'
          });
        }
      });
    });

    document.getElementById('selection-practice-btn').addEventListener('click', () => {
      const draft = app.state.selectionDraft;
      if (!draft || !draft.text) return;
      app.ui.hideSelectionMenu();
      if (draft.text.length < 40) {
        alert('Fuer Uebungsaufgaben bitte mindestens 40 Zeichen markieren.');
        return;
      }
      const templates = app.logic.getPracticeTemplates();
      const cardsHtml = templates.map((t, idx) => (
        `<button type="button" class="selection-template ${idx === 0 ? 'active' : ''}" data-practice-template="${app.utils.safeText(t.id)}">` +
        `<strong>${app.utils.safeText(t.label)}</strong>` +
        `<small>${app.utils.safeText(t.description || '')}</small>` +
        `<small>${app.utils.safeText(t.duration || '')}</small>` +
        '</button>'
      )).join('');
      const difficultyOptions = (app.logic.getLearningTemplates()?.practice?.difficulties || ['leicht', 'mittel', 'anspruchsvoll'])
        .map((d) => `<option value="${app.utils.safeText(d)}"${d === 'mittel' ? ' selected' : ''}>${app.utils.safeText(d)}</option>`)
        .join('');

      app.ui.openSelectionActionModal({
        title: 'Uebungsaufgaben aus Markierung',
        preview: draft.text.slice(0, 450),
        fieldsHtml:
          `<div class="selection-field"><label>Vorlage</label><div class="selection-template-grid">${cardsHtml}</div></div>` +
          '<div class="selection-field"><label for="selection-practice-count">Anzahl Aufgaben</label><select id="selection-practice-count"><option value="4">4</option><option value="6" selected>6</option><option value="8">8</option><option value="10">10</option></select></div>' +
          `<div class="selection-field"><label for="selection-practice-difficulty">Niveau</label><select id="selection-practice-difficulty">${difficultyOptions}</select></div>`,
        confirmLabel: 'Uebungsaufgaben erstellen',
        onConfirm: async () => {
          const activeTemplate = document.querySelector('.selection-template.active');
          const templateId = activeTemplate?.getAttribute('data-practice-template') || templates[0]?.id;
          const count = Number(document.getElementById('selection-practice-count')?.value || 6);
          const difficulty = String(document.getElementById('selection-practice-difficulty')?.value || 'mittel');

          const result = await app.logic.requestSelectionPractice(draft.text, { templateId, count, difficulty });
          app.logic.openPracticeTabWithPayload({
            ...result,
            generatedAt: app.utils.nowStamp(),
            sourceLength: draft.text.length
          });
        }
      });

      const wrap = document.getElementById('selection-action-fields');
      if (wrap) {
        wrap.querySelectorAll('[data-practice-template]').forEach((btn) => {
          btn.addEventListener('click', () => {
            wrap.querySelectorAll('[data-practice-template]').forEach((b) => b.classList.remove('active'));
            btn.classList.add('active');
          });
        });
      }
    });

    document.getElementById('selection-translate-btn').addEventListener('click', () => {
      const draft = app.state.selectionDraft;
      if (!draft || !draft.text) return;
      app.ui.hideSelectionMenu();
      if (draft.text.length > 250) {
        alert('Übersetzen ist nur bis 250 Zeichen möglich.');
        return;
      }
      app.ui.openSelectionActionModal({
        title: 'Text übersetzen',
        preview: draft.text,
        fieldsHtml:
          '<div class="selection-field"><label for="selection-lang">Zielsprache</label><select id="selection-lang"><option value="EN">Englisch</option><option value="ES">Spanisch</option><option value="FR">Französisch</option><option value="TR">Türkisch</option></select></div>',
        confirmLabel: 'Übersetzen',
        onConfirm: async () => {
          const lang = document.getElementById('selection-lang')?.value || 'EN';
          const translated = await app.logic.requestSelectionTranslation(draft.text, lang);
          app.ui.openSelectionResultModal('Übersetzung', translated || 'Keine Übersetzung erhalten.', { lang });
        }
      });
    });

    document.getElementById('selection-rewrite-btn').addEventListener('click', () => {
      const draft = app.state.selectionDraft;
      if (!draft || !draft.text) return;
      app.ui.hideSelectionMenu();
      if (draft.text.length > 500) {
        alert('Komprimieren ist nur bis 500 Zeichen möglich.');
        return;
      }
      app.ui.openSelectionActionModal({
        title: 'Komprimiere Inhalt',
        preview: draft.text,
        fieldsHtml:
          '<div class="selection-field"><label for="selection-rewrite-mode">Variante</label><select id="selection-rewrite-mode"><option value="easy">Einfachere Beschreibung</option><option value="detailed">Ausführlichere Beschreibung</option><option value="crisp">Kurz und knackig zusammenfassen</option></select></div>',
        confirmLabel: 'Optimieren',
        onConfirm: async () => {
          const mode = document.getElementById('selection-rewrite-mode')?.value || 'easy';
          const rewritten = await app.logic.requestSelectionRewrite(draft.text, mode);
          app.ui.openSelectionResultModal('Komprimierter Inhalt', rewritten || 'Kein Text erhalten.');
        }
      });
    });

    document.getElementById('selection-result-copy').addEventListener('click', async () => {
      const txt = document.getElementById('selection-result-text')?.value || '';
      try {
        await navigator.clipboard.writeText(txt);
      } catch (_) {}
    });

    document.getElementById('selection-result-speak').addEventListener('click', async () => {
      const btn = document.getElementById('selection-result-speak');
      const modal = document.getElementById('selection-result-modal');
      const txt = document.getElementById('selection-result-text')?.value || '';
      const lang = modal?.dataset?.speechLang || navigator.language || 'de-DE';
      const preferApi = (modal?.dataset?.speechPreferApi || 'true') !== 'false';
      const voice = String(modal?.dataset?.speechVoice || 'alloy');
      const speed = Number(modal?.dataset?.speechSpeed || 1);
      const synth = window.speechSynthesis;
      if (app.logic.isApiSpeechPlaying() || (app.logic.isSpeechSupported() && synth.speaking)) {
        app.logic.stopSpeech();
        if (btn) btn.textContent = 'Vorlesen';
        return;
      }
      if (btn) btn.textContent = 'Stop';
      try {
        await app.logic.speakText(txt, lang, { preferApi, voice, speed });
      } catch (e) {
        alert(String(e?.message || 'Sprachausgabe fehlgeschlagen.'));
      } finally {
        if (btn) btn.textContent = 'Vorlesen';
      }
    });

    document.getElementById('selection-result-close').addEventListener('click', () => {
      app.ui.closeSelectionResultModal();
    });

    document.addEventListener('click', (e) => {
      if (!e.target.closest('#snippet-popup') && !e.target.closest('.input-wrap')) {
        document.getElementById('snippet-popup').classList.remove('active');
      }
      if (!e.target.closest('#selection-menu')) {
        app.ui.hideSelectionMenu();
      }
      if (e.target.id === 'selection-result-modal') {
        app.ui.closeSelectionResultModal();
      }
      if (e.target.classList.contains('modal-overlay')) app.ui.closeModals();
    });

    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', app.ui.syncViewportInsets, { passive: true });
      window.visualViewport.addEventListener('scroll', app.ui.syncViewportInsets, { passive: true });
      app.ui.syncViewportInsets();
    }

    if (app.state.consentGiven && app.state.sessions.length === 0) {
      app.logic.newChat();
    } else if (app.state.sessions.length > 0) {
      const activeExists = app.state.sessions.some((s) => s.id === app.state.activeId);
      if (!activeExists) app.state.activeId = app.state.sessions[0].id;
      app.logic.switchSession(app.state.activeId);
    }

    window.addEventListener('offline', () => {
      const bubble = app.ui.createBubble('assistant', '⚠️ Offline erkannt: Antworten über APIs sind aktuell nicht verfügbar.');
      app.ui.log.appendChild(bubble);
      app.ui.scrollBottom();
    });
  };

  const params = new URLSearchParams(window.location.search);
  if (params.get('view') === 'cards') {
    initCardTab();
  } else if (params.get('view') === 'practice') {
    initPracticeTab();
  } else {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initMainApp);
    } else {
      initMainApp();
    }
  }
})();
</script>
</body>
</html>
